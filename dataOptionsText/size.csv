TEGRA_AHB;Adds AHB configuration functionality for NVIDIA Tegra SoCs, which controls AHB bus master arbitration and some performance parameters (priority, prefetch size).
CMA_SIZE_MBYTES;Defines the size (in MiB) of the default memory area for Contiguous Memory Allocator.  If the size of 0 is selected, CMA is disabled by default, but it can be enabled by passing cma=size[MG] to the kernel.
CMA_SIZE_PERCENTAGE;Defines the size of the default memory area for Contiguous Memory Allocator as a percentage of the total memory in the system. If 0 percent is selected, CMA is disabled by default, but it can be enabled by passing cma=size[MG] to the kernel.
CMA_ALIGNMENT;DMA mapping framework by default aligns all buffers to the smallest PAGE_SIZE order which is greater than or equal to the requested buffer size. This works well for buffers up to a few hundreds kilobytes, but for larger buffers it just a memory waste. With this parameter you can specify the maximum PAGE_SIZE order for contiguous buffers. Larger buffers will be aligned only to this specified order. The order is expressed as a power of two multiplied by the PAGE_SIZE.  For example, if your system defaults to 4KiB pages, the order value of 8 means that the buffers will be aligned up to 1MiB only.  If unsure, leave the default value 8.
MTD_CMDLINE_PARTS;Allow generic configuration of the MTD partition tables via the kernel command line. Multiple flash resources are supported for hardware where different kinds of flash memory are available.  You will still need the parsing functions to be called by the driver for your particular device. It won't happen automatically. The SA1100 map driver (CONFIG_MTD_SA1100) has an option for this, for example.  The format for the command line is as follows:  mtdparts=<mtddef>[.<mtddef] <mtddef>  := <mtd-id>:<partdef>[,<partdef>] <partdef> := <size>[@offset][<name>][ro] <mtd-id>  := unique id used in mapping driver/device <size>    := standard linux memsize OR - to denote all remaining space <name>    := (NAME)  Due to the way Linux handles the command line, no spaces are allowed in the partition definition, including mtd id's and partition names.  Examples:  1 flash resource (mtd-id sa1100), with 1 single writable partition: mtdparts=sa1100:-  Same flash, but 2 named partitions, the first one being read-only: mtdparts=sa1100:256k(ARMboot)ro,-(root)  If unsure, say 'N'.
MTD_AFS_PARTS;The ARM Firmware Suite allows the user to divide flash devices into multiple 'images'. Each such image has a header containing its name and offset/size etc.  If you need code which can detect and parse these tables, and register MTD 'partitions' corresponding to each image detected, enable this option.  You will still need the parsing functions to be called by the driver for your particular device. It won't happen automatically. The 'physmap' map driver (CONFIG_MTD_PHYSMAP) does this, for example.
MTD_BLOCK;Although most flash chips have an erase size too large to be useful as block devices, it is possible to use MTD devices which are based on RAM chips in this manner. This block device is a user of MTD devices performing that function.  At the moment, it is also required for the Journalling Flash File System(s) to obtain a handle on the MTD device when it's mounted (although JFFS and JFFS2 don't actually use any of the functionality of the mtdblock device).  Later, it may be extended to perform read/erase/modify/write cycles on flash chips to emulate a smaller block size. Needless to say, this is very unsafe, but could be useful for file systems which are almost never written to.  You do not need this option for use with the DiskOnChip devices. For those, enable NFTL support (CONFIG_NFTL) instead.
MTD_CFI_ADV_OPTIONS;If you need to specify a specific endianness for access to flash chips, or if you wish to reduce the size of the kernel by including support for only specific arrangements of flash chips, say 'Y'. This option does not directly affect the code, but will enable other configuration options which allow you to do so.  If unsure, say 'N'.
MTD_CFI_GEOMETRY;This option does not affect the code directly, but will enable some other configuration options which would allow you to reduce the size of the kernel by including support for only certain arrangements of CFI chips. If unsure, say 'N' and all options which are supported by the current code will be enabled.
MTD_PHYSMAP;This provides a 'mapping' driver which allows the NOR Flash and ROM driver code to communicate with chips which are mapped physically into the CPU's memory. You will need to configure the physical address and size of the flash chips on your particular board as well as the bus width, either statically with config options or at run-time.  To compile this driver as a module, choose M here: the module will be called physmap.
MTD_PCMCIA;Map driver for accessing PCMCIA linear flash memory cards. These cards are usually around 4-16MiB in size. This does not include Compact Flash cards which are treated as IDE devices.
MTD_PMC551;This provides a MTD device driver for the Ramix PMC551 RAM PCI card from Ramix Inc. <http://www.ramix.com/products/memory/pmc551.html>. These devices come in memory configurations from 32M - 1G.  If you have one, you probably want to enable this.  If this driver is compiled as a module you get the ability to select the size of the aperture window pointing into the devices memory. What this means is that if you have a 1G card, normally the kernel will use a 1G memory map as its view of the device.  As a module, you can select a 1M window into the memory and the driver will slide the window around the PMC551's memory.  This was particularly useful on the 2.2 kernels on PPC architectures as there was limited kernel space to deal with.
MTDRAM_TOTAL_SIZE;This allows you to configure the total size of the MTD device emulated by the MTDRAM driver.  If the MTDRAM driver is built as a module, it is also possible to specify this as a parameter when loading the module.
MTDRAM_ERASE_SIZE;This allows you to configure the size of the erase blocks in the device emulated by the MTDRAM driver.  If the MTDRAM driver is built as a module, it is also possible to specify this as a parameter when loading the module.
MTD_NAND_VF610_NFC;Enables support for NAND Flash Controller on some Freescale processors like the VF610, MPC5125, MCF54418 or Kinetis K70. The driver supports a maximum 2k page size. With 2k pages and 64 bytes or more of OOB, hardware ECC with up to 32-bit error correction is supported. Hardware ECC is only enabled through device tree.
MTD_ONENAND_2X_PROGRAM;The 2X Program is an extension of Program Operation. Since the device is equipped with two DataRAMs, and two-plane NAND Flash memory array, these two component enables simultaneous program of 4KiB. Plane1 has only even blocks such as block0, block2, block4 while Plane2 has only odd blocks such as block1, block3, block5. So MTD regards it as 4KiB page size and 256KiB block size  Now the following chips support it. (KFXXX16Q2M)   Demux: KFG2G16Q2M, KFH4G16Q2M, KFW8G16Q2M,   Mux:   KFM2G16Q2M, KFN4G16Q2M,  And more recent chips
MTD_SPI_NOR_USE_4K_SECTORS;Many flash memories support erasing small (4096 B) sectors. Depending on the usage this feature may provide performance gain in comparison to erasing whole blocks (32/64 KiB). Changing a small part of the flash's contents is usually faster with small sectors. On the other hand erasing should be faster when using 64 KiB block instead of 16 Ã— 4 KiB sectors.  Please note that some tools/drivers/filesystems may not work with 4096 B erase size (e.g. UBIFS requires 15 KiB as a minimum).
MTD_UBI_BEB_LIMIT;This option specifies the maximum bad physical eraseblocks UBI expects on the MTD device (per 1024 eraseblocks). If the underlying flash does not admit of bad eraseblocks (e.g. NOR flash), this value is ignored.  NAND datasheets often specify the minimum and maximum NVM (Number of Valid Blocks) for the flashes' endurance lifetime. The maximum expected bad eraseblocks per 1024 eraseblocks then can be calculated as 1024 * (1 - MinNVB / MaxNVB), which gives 20 for most NANDs (MaxNVB is basically the total count of eraseblocks on the chip).  To put it differently, if this value is 20, UBI will try to reserve about 1.9% of physical eraseblocks for bad blocks handling. And that will be 1.9% of eraseblocks on the entire NAND chip, not just the MTD partition UBI attaches. This means that if you have, say, a NAND flash chip admits maximum 40 bad eraseblocks, and it is split on two MTD partitions of the same size, UBI will reserve 40 eraseblocks when attaching a partition.  This option can be overridden by the mtd= UBI module parameter or by the attach ioctl.  Leave the default value if unsure.
BLK_DEV_RAM_SIZE;The default value is 4096 kilobytes. Only change this if you know what you are doing.
CHR_DEV_SG;If you want to use SCSI scanners, synthesizers or CD-writers or just about anything having SCSI in its name other than hard disks, CD-ROMs or tapes, say Y here. These won't be supported by the kernel directly, so you need some additional software which knows how to talk to these devices using the SCSI protocol:  For scanners, look at SANE (<http://www.sane-project.org/>). For CD writer software look at Cdrtools (<http://cdrecord.berlios.de/private/cdrecord.html>) and for burning a disk at once: CDRDAO (<http://cdrdao.sourceforge.net/>). Cdparanoia is a high quality digital reader of audio CDs (<http://www.xiph.org/paranoia/>). For other devices, it's possible that you'll have to write the driver software yourself. Please read the file <file:Documentation/scsi/scsi-generic.txt> for more information.  To compile this driver as a module, choose M here and read <file:Documentation/scsi/scsi.txt>. The module will be called sg.  If unsure, say N.
SCSI_EATA_MAX_TAGS;This specifies how many SCSI commands can be maximally queued for each probed SCSI device. You should reduce the default value of 16 only if you have disks with buggy or limited tagged command support. Minimum is 2 and maximum is 62. This value is also the window size used by the elevator sorting option above. The effective value used by the driver for each probed SCSI device is reported at boot time. This is equivalent to the eata=mq:8 boot option.
ATA_VERBOSE_ERROR;This option adds parsing of ATA command descriptions and error bits in libata kernel output, making it easier to interpret. This option will enlarge the kernel by approx. 6KB. Disable it only if kernel size is more important than ease of debugging.  If unsure, say Y.
MD_RAID10;RAID-10 provides a combination of striping (RAID-0) and mirroring (RAID-1) with easier configuration and more flexible layout. Unlike RAID-0, but like RAID-1, RAID-10 requires all devices to be the same size (or at least, only as much as the smallest device will be used). RAID-10 provides a variety of layouts that provide different levels of redundancy and performance.  RAID-10 requires mdadm-1.7.0 or later, available at:  https://www.kernel.org/pub/linux/utils/raid/mdadm/  If unsure, say Y.
DM_SWITCH;This device-mapper target creates a device that supports an arbitrary mapping of fixed-size regions of I/O across a fixed set of paths. The path used for any specific region can be switched dynamically by sending the target a message.  To compile this code as a module, choose M here: the module will be called dm-switch.  If unsure, say N.
ATM_ENI_TUNE_BURST;In order to obtain good throughput, the ENI NIC can transfer multiple words of data per PCI bus access cycle. Such a multi-word transfer is called a burst.  The default settings for the burst sizes are suitable for most PCI chipsets. However, in some cases, large bursts may overrun buffers in the PCI chipset and cause data corruption. In such cases, large bursts must be disabled and only (slower) small bursts can be used. The burst sizes can be set independently in the send (TX) and receive (RX) direction.  Note that enabling many different burst sizes in the same direction may increase the cost of setting up a transfer such that the resulting throughput is lower than when using only the largest available burst size.  Also, sometimes larger bursts lead to lower throughput, e.g. on an Intel 440FX board, a drop from 135 Mbps to 103 Mbps was observed when going from 8W to 16W bursts.
ATM_IDT77252_DEBUG;Somewhat useful debugging messages are available. The choice of messages is controlled by a bitmap.  This may be specified as a module argument.  See the file <file:drivers/atm/idt77252.h> for the meanings of the bits in the mask.  When active, these messages can have a significant impact on the speed of the driver, and the size of your syslog files! When inactive, they will have only a modest impact on performance.
ATM_AMBASSADOR_DEBUG;Somewhat useful debugging messages are available. The choice of messages is controlled by a bitmap.  This may be specified as a module argument (kernel command line argument as well?), changed dynamically using an ioctl (not yet) or changed by sending the string Dxxxx to VCI 1023 (where x is a hex digit).  See the file <file:drivers/atm/ambassador.h> for the meanings of the bits in the mask.  When active, these messages can have a significant impact on the speed of the driver, and the size of your syslog files! When inactive, they will have only a modest impact on performance.
ATM_HORIZON_DEBUG;Somewhat useful debugging messages are available. The choice of messages is controlled by a bitmap.  This may be specified as a module argument (kernel command line argument as well?), changed dynamically using an ioctl (not yet) or changed by sending the string Dxxxx to VCI 1023 (where x is a hex digit).  See the file <file:drivers/atm/horizon.h> for the meanings of the bits in the mask.  When active, these messages can have a significant impact on the speed of the driver, and the size of your syslog files! When inactive, they will have only a modest impact on performance.
ATM_IA;This is a driver for the Interphase (i)ChipSAR adapter cards which include a variety of variants in term of the size of the control memory (128K-1KVC, 512K-4KVC), the size of the packet memory (128K, 512K, 1M), and the PHY type (Single/Multi mode OC3, UTP155, UTP25, DS3 and E3). Go to:       <http://www.iphase.com/> for more info about the cards. Say Y (or M to compile as a module named iphase) here if you have one of these cards.  See the file <file:Documentation/networking/iphase.txt> for further details.
ATM_IA_DEBUG;Somewhat useful debugging messages are available. The choice of messages is controlled by a bitmap. This may be specified as a module argument (kernel command line argument as well?), changed dynamically using an ioctl (Get the debug utility, iadbg, from <ftp://ftp.iphase.com/pub/atm/pci/>).  See the file <file:drivers/atm/iphase.h> for the meanings of the bits in the mask.  When active, these messages can have a significant impact on the speed of the driver, and the size of your syslog files! When inactive, they will have only a modest impact on performance.
ATM_FORE200E_DEBUG;Specifies the level of debugging messages issued by the driver. The verbosity of the driver increases with the value of this parameter.  When active, these messages can have a significant impact on the performances of the driver, and the size of your syslog files! Keep the debugging level to 0 during normal operations.
ACENIC_OMIT_TIGON_I;Say Y here if you only have Tigon II based AceNICs and want to leave out support for the older Tigon I based cards which are no longer being sold (ie. the original Alteon AceNIC and 3Com 3C985 (non B version)).  This will reduce the size of the driver object by app. 100KB.  If you are not sure whether your card is a Tigon I or a Tigon II, say N here.  The safe and default value for this is N.
TULIP_MWI;This configures your Tulip card specifically for the card and system cache line size type you are using.  This is experimental code, not yet tested on many boards.  If unsure, say N.
8139TOO_8129;This enables support for the older and uncommon RTL-8129 and RTL-8130 chips, which support MII via an external transceiver, instead of an internal one.  Disabling this option will save some memory by making the code size smaller.  If unsure, say Y.
ATH9K_DFS_CERTIFIED;This option enables DFS support for initiating radiation on ath9k. There is no way to dynamically detect if a card was DFS certified and as such this is left as a build time option. This option should only be enabled by system integrators that can guarantee that all the platforms that their kernel will run on have obtained appropriate regulatory body certification for a respective Atheros card by using ath9k on the target shipping platforms.  This is currently only a placeholder for future DFS support, as DFS support requires more components that still need to be developed. At this point enabling this option won't do anything except increase code size.
B43LEGACY_DMA_MODE;Only include Direct Memory Access (DMA). This reduces the size of the driver module, by omitting the PIO code.
B43LEGACY_PIO_MODE;Only include Programmed I/O (PIO). This reduces the size of the driver module, by omitting the DMA code. Please note that PIO transfers are slow (compared to DMA).  Also note that not all devices of the b43legacy series support PIO.  You should use PIO only if DMA does not work for you.
IWLWIFI_DEVICE_TRACING;Say Y here to trace all commands, including TX frames and IO accesses, sent to the device. If you say yes, iwlwifi will register with the ftrace framework for event tracing and dump all this information to the ringbuffer, you may need to increase the ringbuffer size. See the ftrace documentation for more information.  When tracing is not enabled, this option still has some (though rather small) overhead.  If unsure, say Y so we can help you better when problems occur.
CAPI_TRACE;If you say Y here, the kernelcapi driver can make verbose traces of CAPI messages. This feature can be enabled/disabled via IOCTL for every controller (default disabled). This will increase the size of the kernelcapi module by 20 KB. If unsure, say Y.
ISDN_CAPI_CAPIDRV_VERBOSE;If you say Y here, the capidrv interface will give verbose reasons for disconnecting. This will increase the size of the kernel by 7 KB. If unsure, say N.
NVM_RRPC;Allows an open-channel SSD to be exposed as a block device to the host. The target is implemented using a linear mapping table and cost-based garbage collection. It is optimized for 4K IO sizes.
SERIAL_8250_CS;Say Y here to enable support for 16-bit PCMCIA serial devices, including serial port cards, modems, and the modem functions of multi-function Ethernet/modem cards. (PCMCIA- or PC-cards are credit-card size devices often used with laptops.)  To compile this driver as a module, choose M here: the module will be called serial_cs.  If unsure, say N.
DTLK;This driver is for the DoubleTalk PC, a speech synthesizer manufactured by RC Systems (<http://www.rcsys.com/>).  It is also called the `internal DoubleTalk'.  To compile this driver as a module, choose M here: the module will be called dtlk.
HMC_DRV;This option enables support for file transfers from a Hardware Management Console (HMC) drive CD/DVD-ROM. It is available as a module, called 'hmcdrv', and also as kernel built-in. There is one optional parameter for this module: cachesize=N, which modifies the transfer cache size from it's default value 0.5MB to N bytes. If N is zero, then no caching is performed.
SSB_SILENT;This option turns off all Sonics Silicon Backplane printks. Note that you won't be able to identify problems, once messages are turned off. This might only be desired for production kernels on embedded devices to reduce the kernel size.  Say N
VIDEO_V4L2_SUBDEV_API;Enables the V4L2 sub-device pad-level userspace API used to configure video format, size and frame rate between hardware blocks.  This API is mostly used by camera interfaces in embedded platforms.
DVB_USB_UMT_010;Say Y here to support the HanfTek UMT-010 USB2.0 stick-sized DVB-T receiver.
DVB_USB_DTT200U;Say Y here to support the WideView/Yakumo/Hama/Typhoon/Yuan DVB-T USB2.0 receiver.  The receivers are also known as DTT200U (Yakumo) and UB300 (Yuan).  The WT-220U and its clones are pen-sized.
MEDIA_SUBDRV_AUTOSELECT;By default, a media driver auto-selects all possible ancillary devices such as tuners, sensors, video encoders/decoders and frontends, that are used by any of the supported devices.  This is generally the right thing to do, except when there are strict constraints with regards to the kernel size, like on embedded systems.  Use this option with care, as deselecting ancillary drivers which are, in fact, necessary will result in the lack of the needed functionality for your device (it may not tune or may not have the needed demodulators).  If unsure say Y.
FB_MODE_HELPERS;This enables functions for handling video modes using the Generalized Timing Formula and the EDID parser. A few drivers rely on this feature such as the radeonfb, rivafb, and the i810fb. If your driver does not take advantage of this feature, choosing Y will just increase the kernel size by about 5K.
FB_PS3_DEFAULT_SIZE_M;This is the default size (in MiB) of the virtual frame buffer in the PS3. The default value can be overridden on the kernel command line using the ps3fb option (e.g. ps3fb=9M).
FB_SIMPLE;Say Y if you want support for a simple frame-buffer.  This driver assumes that the display hardware has been initialized before the kernel boots, and the kernel will simply render to the pre-allocated frame buffer surface.  Configuration re: surface address, size, and format must be provided through device tree, or plain old platform data.
VGACON_SOFT_SCROLLBACK;The scrollback buffer of the standard VGA console is located in the VGA RAM.  The size of this RAM is fixed and is quite small. If you require a larger scrollback buffer, this can be placed in System RAM which is dynamically allocated during initialization. Placing the scrollback buffer in System RAM will slightly slow down the console.  If you want this feature, say 'Y' here and enter the amount of RAM to allocate for this buffer.  If unsure, say 'N'.
VGACON_SOFT_SCROLLBACK_SIZE;Enter the amount of System RAM to allocate for scrollback buffers of VGA consoles. Each 64KB will give you approximately 16 80x25 screenfuls of scrollback buffer.
VGACON_SOFT_SCROLLBACK_PERSISTENT_ENABLE_BY_DEFAULT;Say Y here if the scrollback history should persist by default when switching between consoles. Otherwise, the scrollback history will be flushed each time the console is switched. This feature can also be enabled using the boot command line parameter 'vgacon.scrollback_persistent=1'.  This feature might break your tool of choice to flush the scrollback buffer, e.g. clear(1) will work fine but Debian's clear_console(1) will be broken, which might cause security issues. You can use the escape sequence \e[3J instead if this feature is activated.  Note that a buffer of VGACON_SOFT_SCROLLBACK_SIZE is taken for each created tty device. So if you use a RAM-constrained system, say N here.
SND_PROC_FS;Say 'N' to disable Sound proc FS, which may reduce code size about 9KB on x86_64 platform. If unsure say Y.
SND_HDA_PREALLOC_SIZE;Specifies the default pre-allocated buffer-size in kB for the HD-audio driver.  A larger buffer (e.g. 2048) is preferred for systems using PulseAudio.  The default 64 is chosen just for compatibility reasons.  Note that the pre-allocation size can be changed dynamically via a proc file (/proc/asound/card*/pcm*/sub*/prealloc), too.
MSNDPIN_IRQ;Interrupt request line for the primary synthesizer on MultiSound Pinnacle and Fiji sound cards.
MSNDPIN_MEM;Memory-mapped I/O base address for the primary synthesizer on MultiSound Pinnacle and Fiji sound cards.
MSNDPIN_IO;Memory-mapped I/O base address for the primary synthesizer on MultiSound Pinnacle and Fiji sound cards.
MSNDPIN_MPU_IO;Memory-mapped I/O base address for the Kurzweil daughterboard synthesizer on MultiSound Pinnacle and Fiji sound cards.
MSNDPIN_MPU_IRQ;Interrupt request number for the Kurzweil daughterboard synthesizer on MultiSound Pinnacle and Fiji sound cards.
MSND_FIFOSIZE;Configures the size of each audio buffer, in kilobytes, for recording and playing in the MultiSound drivers (both the Classic and Pinnacle). Larger values reduce the chance of data overruns at the expense of overall latency. If unsure, use the default.
SOUND_MSS;Again think carefully before answering Y to this question.  It's safe to answer Y if you have the original Windows Sound System card made by Microsoft or Aztech SG 16 Pro (or NX16 Pro).  Also you may say Y in case your card is NOT among these:  ATI Stereo F/X, AdLib, Audio Excell DSP16, Cardinal DSP16, Ensoniq SoundScape (and compatibles made by Reveal and Spea), Gravis Ultrasound, Gravis Ultrasound ACE, Gravis Ultrasound Max, Gravis Ultrasound with 16 bit option, Logitech Sound Man 16, Logitech SoundMan Games, Logitech SoundMan Wave, MAD16 Pro (OPTi 82C929), Media Vision Jazz16, MediaTriX AudioTriX Pro, Microsoft Windows Sound System (MSS/WSS), Mozart (OAK OTI-601), Orchid SW32, Personal Sound System (PSS), Pro Audio Spectrum 16, Pro Audio Studio 16, Pro Sonic 16, Roland MPU-401 MIDI interface, Sound Blaster 1.0, Sound Blaster 16, Sound Blaster 16ASP, Sound Blaster 2.0, Sound Blaster AWE32, Sound Blaster Pro, TI TM4000M notebook, ThunderBoard, Turtle Beach Tropez, Yamaha FM synthesizers (OPL2, OPL3 and OPL4), 6850 UART MIDI Interface.  For cards having native support in VoxWare, consult the card specific instructions in <file:Documentation/sound/oss/README.OSS>. Some drivers have their own MSS support and saying Y to this option will cause a conflict.  If you compile the driver into the kernel, you have to add ad1848=<io>,<irq>,<dma>,<dma2>[,<type>] to the kernel command line.
USB_ATMEL_USBA;USBA is the integrated high-speed USB Device controller on the AT32AP700x, some AT91SAM9 and AT91CAP9 processors from Atmel.  The fifo_mode parameter is used to select endpoint allocation mode. fifo_mode = 0 is used to let the driver autoconfigure the endpoints. In this case, for ep1 2 banks are allocated if it works in isochronous mode and only 1 bank otherwise. For the rest of the endpoints only 1 bank is allocated.  fifo_mode = 1 is a generic maximum fifo size (1024 bytes) configuration allowing the usage of ep1 - ep6  fifo_mode = 2 is a generic performance maximum fifo size (1024 bytes) configuration allowing the usage of ep1 - ep3  fifo_mode = 3 is a balanced performance configuration allowing the the usage of ep1 - ep8
USB_AUDIO;This Gadget Audio driver is compatible with USB Audio Class specification 2.0. It implements 1 AudioControl interface, 1 AudioStreaming Interface each for USB-OUT and USB-IN. Number of channels, sample rate and sample size can be specified as module parameters. This driver doesn't expect any real Audio codec to be present on the device - the audio streams are simply sinked to and sourced from a virtual ALSA sound card created. The user-space application may choose to do whatever it wants with the data received from the USB Host and choose to provide whatever it wants as audio data to the USB Host.  Say y to link the driver statically, or m to build a dynamically linked module called g_audio.
MMC_SDHCI_BIG_ENDIAN_32BIT_BYTE_SWAPPER;This option is selected by drivers running on big endian hosts and performing I/O to a SDHCI controller through a bus that implements a hardware byte swapper using a 32-bit datum. This endian mapping mode is called data invariance and has the effect of scrambling the addresses and formats of data accessed in sizes other than the datum size.  This is the case for the Nintendo Wii SDHCI.
UIO_DMEM_GENIRQ;Platform driver for Userspace I/O devices, including generic interrupt handling code. Shared interrupts are not supported.  Memory regions can be specified with the same platform device resources as the UIO_PDRV drivers, but dynamic regions can also be specified. The number and size of these regions is static, but the memory allocation is not performed until the associated device file is opened. The memory is freed once the uio device is closed.  If you don't know what to do here, say N.
XEN_BALLOON_MEMORY_HOTPLUG;Memory hotplug support for Xen balloon driver allows expanding memory available for the system above limit declared at system startup. It is very useful on critical systems which require long run without rebooting.  Memory could be hotplugged in following steps:    1) target domain: ensure that memory auto online policy is in      effect by checking /sys/devices/system/memory/auto_online_blocks      file (should be 'online').    2) control domain: xl mem-max <target-domain> <maxmem>      where <maxmem> is >= requested memory size,    3) control domain: xl mem-set <target-domain> <memory>      where <memory> is requested memory size. alternatively memory      could be added by writing proper value to      /sys/devices/system/xen_memory/xen_memory0/target or      /sys/devices/system/xen_memory/xen_memory0/target_kb on the      target domain.  Alternatively, if memory auto onlining was not requested at step 1 the newly added memory can be manually onlined in the target domain by doing the following:        for i in /sys/devices/system/memory/memory*/state. do \         [ `cat $i` = offline ] && echo online > $i. done  or by adding the following line to udev rules:  SUBSYSTEM==memory, ACTION==add, RUN+=/bin/sh -c '[ -f /sys$devpath/state ] && echo online > /sys$devpath/state'
COMEDI_DEFAULT_BUF_SIZE_KB;This is the default asynchronous buffer size which is used for commands running in the background in kernel space.  This defaults to 2048 KiB of memory so that a 16 channel card running at 10 kHz has of 2-4 seconds of buffer.
COMEDI_DEFAULT_BUF_MAXSIZE_KB;This is the default maximum asynchronous buffer size which can be requested by a userspace program without root privileges. This is set to 20480 KiB so that a fast I/O card with 16 channels running at 100 kHz has 2-4 seconds of buffer.
SPEAKUP;This is the Speakup screen reader.  Think of it as a video console for blind people.  If built in to the kernel, it can speak everything on the text console from boot up to shutdown.  For more information on Speakup, point your browser at <http://www.linux-speakup.org/>. There is also a mailing list at the above url that you can subscribe to.  Supported synthesizers are accent sa, accent pc, appollo II., Auddapter, Braille 'n Speak, Dectalk external (old), Dectalk PC (full length isa board), Dectalk express, Doubletalk, Doubletalk LT or Litetalk, Keynote Gold internal PC, software synthesizers, Speakout, transport, and a dummy module that can be used with a plain text terminal.  Speakup can either be built in or compiled as a module by answering y or m.  If you answer y here, then you must answer either y or m to at least one of the synthesizer drivers below.  If you answer m here, then the synthesizer drivers below can only be built as modules.  These drivers are not standalone drivers, but must be used in conjunction with Speakup.  Think of them as video cards for blind people.   The Dectalk pc driver can only be built as a module, and requires software to be pre-loaded on to the card before the module can be loaded.  See the decpc choice below for more details.  If you are not a blind person, or don't have access to one of the listed synthesizers, you should say n.
SPEAKUP_SYNTH_ACNTSA;This is the Speakup driver for the Accent SA synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_ACNTPC;This is the Speakup driver for the accent pc synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_APOLLO;This is the Speakup driver for the Apollo II synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_AUDPTR;This is the Speakup driver for the Audapter synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_BNS;This is the Speakup driver for the Braille 'n' Speak synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_DECTLK;This is the Speakup driver for the DecTalk Express synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_DECEXT;This is the Speakup driver for the DecTalk External (old) synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_DECPC;This is the Speakup driver for the DecTalk PC (full length ISA) synthesizer.  You can say m to build it as a module.  See the configuration help on the Speakup choice above for more info.  In order to use the DecTalk PC driver, you must download the dec_pc.tgz file from linux-speakup.org.  It is in the pub/linux/goodies directory.  The dec_pc.tgz file contains the software which must be pre-loaded on to the DecTalk PC board in order to use it with this driver. This driver must be built as a module, and can not be loaded until the file system is mounted and the DecTalk PC software has been pre-loaded on to the board.  See the README file in the dec_pc.tgz file for more details.
SPEAKUP_SYNTH_DTLK;This is the Speakup driver for the internal DoubleTalk PC synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_KEYPC;This is the Speakup driver for the Keynote Gold PC synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_LTLK;This is the Speakup driver for the LiteTalk/DoubleTalk LT synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_SOFT;This is the software synthesizer device node.  It will register a device /dev/softsynth which midware programs and speech daemons may open and read to provide kernel output to software synths such as espeak, festival, flite and so forth.  You can select 'y' or 'm' to have it built-in to the kernel or loaded as a module.
SPEAKUP_SYNTH_SPKOUT;This is the Speakup driver for the Speakout synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
SPEAKUP_SYNTH_TXPRT;This is the Speakup driver for the Transport synthesizer.  You can say y to build it into the kernel, or m to build it as a module.  See the configuration help on the Speakup choice above for more info.
ION_CHUNK_HEAP;Choose this option to enable chunk heaps with Ion. This heap is similar in function the carveout heap but memory is broken down into smaller chunk sizes, typically corresponding to a TLB size. Unless you know your system has these regions, you should say N here.
LNET_MAX_PAYLOAD;This option defines the maximum size of payload in bytes that lnet can put into its transport.  If unsure, use default.
LUSTRE_OBD_MAX_IOCTL_BUFFER;This option defines the maximum size of buffer in bytes that user space applications can pass to Lustre kernel module through ioctl interface.  If unsure, use default.
THINKPAD_ACPI_DEBUG;Enables extra debugging information, at the expense of a slightly increase in driver size.  If you are not sure, say N here.
COMMON_CLK_CDCE706;This driver supports TI CDCE706 programmable 3-PLL clock synthesizer.
COMMON_CLK_CDCE925;---help---   This driver supports the TI CDCE913/925/937/949 programmable clock   synthesizer. Each chip has different number of PLLs and outputs.   For example, the CDCE925 contains two PLLs with spread-spectrum   clocking support and five output dividers. The driver only supports   the following setup, and uses a fixed setting for the output muxes.   Y1 is derived from the input clock   Y2 and Y3 derive from PLL1   Y4 and Y5 derive from PLL2   Given a target output frequency, the driver will set the PLL and   divider to best approximate the desired output.
OMAP_MBOX_KFIFO_SIZE;Specify the default size of mailbox's kfifo buffers (bytes). This can also be changed at runtime (via the mbox_kfifo_size module parameter).
IOMMU_IO_PGTABLE_LPAE;Enable support for the ARM long descriptor pagetable format. This allocator supports 4K/2M/1G, 16K/32M and 64K/512M page sizes at both stage-1 and stage-2, as well as address spaces up to 48-bits in size.
PM_DEVFREQ_EVENT;The devfreq-event device provide the raw data and events which indicate the current state of devfreq-event device. The provided data from devfreq-event device is used to monitor the state of device and determine the suitable size of resource to reduce the wasted resource.  The devfreq-event device can support the various type of events (e.g., raw data, utilization, latency, bandwidth). The events may be used by devfreq governor and other subsystem.
ADF4350;Say yes here to build support for Analog Devices  ADF4350/ADF4351 Wideband Synthesizers. The driver provides direct access via sysfs.  To compile this driver as a module, choose M here: the module will be called adf4350.
NTB_IDT;This driver supports NTB of cappable IDT PCIe-switches.  Some of the pre-initializations must be made before IDT PCIe-switch exposes it NT-functions correctly. It should be done by either proper initialisation of EEPROM connected to master smbus of the switch or by BIOS using slave-SMBus interface changing corresponding registers value. Evidently it must be done before PCI bus enumeration is finished in Linux kernel.  First of all partitions must be activated and properly assigned to all the ports with NT-functions intended to be activated (see SWPARTxCTL and SWPORTxCTL registers). Then all NT-function BARs must be enabled with chosen valid aperture. For memory windows related BARs the aperture settings shall determine the maximum size of memory windows accepted by a BAR. Note that BAR0 must map PCI configuration space registers.  It's worth to note, that since a part of this driver relies on the BAR settings of peer NT-functions, the BAR setups can't be done over kernel PCI fixups. That's why the alternative pre-initialization techniques like BIOS using SMBus interface or EEPROM should be utilized. Additionally if one needs to have temperature sensor information printed to system log, the corresponding registers must be initialized within BIOS/EEPROM as well.  If unsure, say N.
ZORRO_NAMES;By default, the kernel contains a database of all known Zorro device names to make the information in /proc/iomem comprehensible to the user. This database increases the size of the kernel image by about 15KB, but it gets freed after the system boots up, so it doesn't take up kernel memory. Anyway, if you are building an installation floppy or kernel for an embedded system where kernel image size really matters, you can disable this feature and you'll get device ID numbers instead of names.  When in doubt, say Y.
CRYPTO_AES_S390;This is the s390 hardware accelerated implementation of the AES cipher algorithms (FIPS-197).  As of z9 the ECB and CBC modes are hardware accelerated for 128 bit keys. As of z10 the ECB and CBC modes are hardware accelerated for all AES key sizes. As of z196 the CTR mode is hardware accelerated for all AES key sizes and XTS mode is hardware accelerated for 256 and 512 bit keys.
CRYPTO_DEV_FSL_CAAM_RINGSIZE;Select size of Job Rings as a power of 2, within the range 2-9 (ring size 4-512). Examples:       2 => 4       3 => 8       4 => 16       5 => 32       6 => 64       7 => 128       8 => 256       9 => 512
CRYPTO_DEV_FSL_CAAM_INTC_COUNT_THLD;Select number of descriptor completions to queue before raising an interrupt, in the range 1-255. Note that a selection of 1 functionally defeats the coalescing feature, and a selection equal or greater than the job ring size will force timeouts.
CRYPTO_DEV_UX500_CRYP;This selects the crypto driver for the UX500_CRYP hardware. It supports AES-ECB, CBC and CTR with keys sizes of 128, 192 and 256 bit sizes.
ACPI_DEBUG;The ACPI subsystem can produce debug output.  Saying Y enables this output and increases the kernel size by around 50K.  Use the acpi.debug_layer and acpi.debug_level kernel command-line parameters documented in Documentation/acpi/debug.txt and Documentation/admin-guide/kernel-parameters.rst to control the type and amount of debug output.
EISA_NAMES;By default, the kernel contains a database of all known EISA device names to make the information in sysfs comprehensible to the user. This database increases size of the kernel image by about 40KB, but it gets freed after the system boots up, so it doesn't take up kernel memory. Anyway, if you are building an installation floppy or kernel for an embedded system where kernel image size really matters, you can disable this feature and you'll get device ID instead of names.  When in doubt, say Y.
PCCARD;Say Y here if you want to attach PCMCIA- or PC-cards to your Linux computer.  These are credit-card size devices such as network cards, modems or hard drives often used with laptops computers.  There are actually two varieties of these cards: 16 bit PCMCIA and 32 bit CardBus cards.  To compile this driver as modules, choose M here: the module will be called pcmcia_core.
JUMP_LABEL;This option enables a transparent branch optimization that makes certain almost-always-true or almost-always-false branch conditions even cheaper to execute within the kernel.  Certain performance-sensitive kernel code, such as trace points, scheduler functionality, networking code and KVM have such branches and include support for this optimization technique.  If it is detected that the compiler has support for asm goto, the kernel will compile such branches with just a nop instruction. When the condition flag is toggled to true, the nop will be converted to a jump instruction to execute the conditional block of instructions.  This technique lowers overhead and stress on the branch prediction of the processor and generally makes the kernel faster. The update of the condition is slower, but those are always very rare.  ( On 32-bit x86, the necessary options added to the compiler   flags may increase the size of the kernel slightly. )
HAVE_ALIGNED_STRUCT_PAGE;This makes sure that struct pages are double word aligned and that e.g. the SLUB allocator can perform double word atomic operations on a struct page for better performance. However selecting this might increase the size of a struct page by a word.
GCC_PLUGIN_RANDSTRUCT_PERFORMANCE;If you say Y here, the RANDSTRUCT randomization will make a best effort at restricting randomization to cacheline-sized groups of elements.  It will further not randomize bitfields in structures.  This reduces the performance hit of RANDSTRUCT at the cost of weakened randomization.
CC_STACKPROTECTOR_REGULAR;Functions will have the stack-protector canary logic added if they have an 8-byte or larger character array on the stack.  This feature requires gcc version 4.2 or above, or a distribution gcc with the feature backported (-fstack-protector).  On an x86 defconfig build, this feature adds canary checks to about 3% of all kernel functions, which increases kernel code size by about 0.3%.
CC_STACKPROTECTOR_STRONG;Functions will have the stack-protector canary logic added in any of the following conditions:  - local variable's address used as part of the right hand side of an   assignment or function argument - local variable is an array (or union containing an array),   regardless of array type or length - uses register local variables  This feature requires gcc version 4.9 or above, or a distribution gcc with the feature backported (-fstack-protector-strong).  On an x86 defconfig build, this feature adds canary checks to about 20% of all kernel functions, which increases the kernel code size by about 2%.
DYNAMIC_DEBUG;Compiles debug level messages into the kernel, which would not otherwise be available at runtime. These messages can then be enabled/disabled based on various levels of scope - per source file, function, module, format string, and line number. This mechanism implicitly compiles in all pr_debug() and dev_dbg() calls, which enlarges the kernel text size by about 2%.  If a source file is compiled with DEBUG flag set, any pr_debug() calls in it are enabled by default, but can be disabled at runtime as below.  Note that DEBUG flag is turned on by many CONFIG_*DEBUG* options.  Usage:  Dynamic debugging is controlled via the 'dynamic_debug/control' file, which is contained in the 'debugfs' filesystem. Thus, the debugfs filesystem must first be mounted before making use of this feature. We refer the control file as: <debugfs>/dynamic_debug/control. This file contains a list of the debug statements that can be enabled. The format for each line of the file is:        filename:lineno [module]function flags format  filename : source file of the debug statement lineno : line number of the debug statement module : module that contains the debug statement function : function that contains the debug statement flags : '=p' means the line is turned 'on' for printing format : the format used for the debug statement  From a live system:        nullarbor:~ # cat <debugfs>/dynamic_debug/control       # filename:lineno [module]function flags format       fs/aio.c:222 [aio]__put_ioctx =_ __put_ioctx:\040freeing\040%p\012       fs/aio.c:248 [aio]ioctx_alloc =_ ENOMEM:\040nr_events\040too\040high\012       fs/aio.c:1770 [aio]sys_io_cancel =_ calling\040cancel\012  Example usage:        // enable the message at line 1603 of file svcsock.c       nullarbor:~ # echo -n 'file svcsock.c line 1603 +p' >                                       <debugfs>/dynamic_debug/control        // enable all the messages in file svcsock.c       nullarbor:~ # echo -n 'file svcsock.c +p' >                                       <debugfs>/dynamic_debug/control        // enable all the messages in the NFS server module       nullarbor:~ # echo -n 'module nfsd +p' >                                       <debugfs>/dynamic_debug/control        // enable all 12 messages in the function svc_process()       nullarbor:~ # echo -n 'func svc_process +p' >                                       <debugfs>/dynamic_debug/control        // disable all 12 messages in the function svc_process()       nullarbor:~ # echo -n 'func svc_process -p' >                                       <debugfs>/dynamic_debug/control  See Documentation/admin-guide/dynamic-debug-howto.rst for additional information.
DEBUG_INFO_REDUCED;If you say Y here gcc is instructed to generate less debugging information for structure types. This means that tools that need full debugging information (like kgdb or systemtap) won't be happy. But if you merely need debugging information to resolve line numbers there is no loss. Advantage is that build directory object sizes shrink dramatically over a full DEBUG_INFO build and compile times are reduced too. Only works with newer gcc versions.
DEBUG_INFO_SPLIT;Generate debug info into separate .dwo files. This significantly reduces the build directory size for builds with DEBUG_INFO, because it stores the information only once on disk in .dwo files instead of multiple times in object files and executables. In addition the debug information is also compressed.  Requires recent gcc (4.7+) and recent gdb/binutils. Any tool that packages or reads debug information would need to know about the .dwo files and include them. Incompatible with older versions of ccache.
DEBUG_KMEMLEAK_EARLY_LOG_SIZE;Kmemleak must track all the memory allocations to avoid reporting false positives. Since memory may be allocated or freed before kmemleak is initialised, an early log buffer is used to store these actions. If kmemleak reports early log buffer exceeded, please increase this value.
KMEMCHECK_QUEUE_SIZE;Select the maximum number of errors to store in the queue. Since errors can occur virtually anywhere and in any context, we need a temporary storage area which is guarantueed not to generate any other faults. The queue will be emptied as soon as a tasklet may be scheduled. If the queue is full, new error reports will be lost.
KASAN_OUTLINE;Before every memory access compiler insert function call __asan_load*/__asan_store*. These functions performs check of shadow memory. This is slower than inline instrumentation, however it doesn't bloat size of kernel's .text section so much as inline does.
KASAN_INLINE;Compiler directly inserts code checking shadow memory before memory accesses. This is faster than outline (in some workloads it gives about x2 boost over outline instrumentation), but make kernel's .text size much bigger. This requires a gcc version of 5.0 or later.
IRQSOFF_TRACER;This option measures the time spent in irqs-off critical sections, with microsecond accuracy.  The default measurement method is a maximum search, which is disabled by default and can be runtime (re-)started via:      echo 0 > /sys/kernel/debug/tracing/tracing_max_latency  (Note that kernel size and overhead increase with this option enabled. This option and the preempt-off timing option can be used together or separately.)
PREEMPT_TRACER;This option measures the time spent in preemption-off critical sections, with microsecond accuracy.  The default measurement method is a maximum search, which is disabled by default and can be runtime (re-)started via:      echo 0 > /sys/kernel/debug/tracing/tracing_max_latency  (Note that kernel size and overhead increase with this option enabled. This option and the irqs-off timing option can be used together or separately.)
RING_BUFFER_STARTUP_TEST;Run a simple self test on the ring buffer on boot up. Late in the kernel boot sequence, the test will start that kicks off a thread per cpu. Each thread will write various size events into the ring buffer. Another thread is created to send IPIs to each of the threads, where the IPI handler will also write to the ring buffer, to test/stress the nesting ability. If any anomalies are discovered, a warning will be displayed and all ring buffers will be disabled.  The test runs for 10 seconds. This will slow your boot time by at least 10 more seconds.  At the end of the test, statics and more checks are done. It will output the stats of each per cpu buffer. What was written, the sizes, what was read, what was lost, and other similar details.  If unsure, say N
TRACE_EVAL_MAP_FILE;The print fmt of the trace events will show the enum/sizeof names instead of their values. This can cause problems for user space tools that use this string to parse the raw data as user space does not know how to convert the string to its value.  To fix this, there's a special macro in the kernel that can be used to convert an enum/sizeof into its value. If this macro is used, then the print fmt strings will be converted to their values.  If something does not get converted properly, this option can be used to show what enums/sizeof the kernel tried to convert.  This option is for debugging the conversions. A file is created in the tracing directory called eval_map that will show the names matched with their values and what trace event system they belong too.  Normally, the mapping of the strings to values will be freed after boot up or module load. With this option, they will not be freed, as they are needed for the eval_map file. Enabling this option will increase the memory footprint of the running kernel.  If unsure, say N
UBSAN_SANITIZE_ALL;This option activates instrumentation for the entire kernel. If you don't enable this option, you have to explicitly specify UBSAN_SANITIZE := y for the files/directories you want to check for UB. Enabling this option will get kernel image size increased significantly.
KERNEL_BZIP2;Its compression ratio and speed is intermediate. Decompression speed is slowest among the choices.  The kernel size is about 10% smaller with bzip2, in comparison to gzip. Bzip2 uses a large amount of memory. For modern kernels you will need at least 8MB RAM or more for booting.
KERNEL_LZMA;This compression algorithm's ratio is best.  Decompression speed is between gzip and bzip2.  Compression is slowest. The kernel size is about 33% smaller with LZMA in comparison to gzip.
KERNEL_XZ;XZ uses the LZMA2 algorithm and instruction set specific BCJ filters which can improve compression ratio of executable code. The size of the kernel is about 30% smaller with XZ in comparison to gzip. On architectures for which there is a BCJ filter (i386, x86_64, ARM, IA-64, PowerPC, and SPARC), XZ will create a few percent smaller kernel than plain LZMA.  The speed is about the same as with LZMA: The decompression speed of XZ is better than that of bzip2 but worse than gzip and LZO. Compression is slow.
KERNEL_LZO;Its compression ratio is the poorest among the choices. The kernel size is about 10% bigger than gzip. however its speed (both compression and decompression) is the fastest.
KERNEL_LZ4;LZ4 is an LZ77-type compressor with a fixed, byte-oriented encoding. A preliminary version of LZ4 de/compression tool is available at <https://code.google.com/p/lz4/>.  Its compression ratio is worse than LZO. The size of the kernel is about 8% bigger than LZO. But the decompression speed is faster than LZO.
HIGH_RES_TIMERS;This option enables high resolution timer support. If your hardware is not capable then this option only increases the size of the kernel image.
LOG_BUF_SHIFT;Select the minimal kernel log buffer size as a power of 2. The final size is affected by LOG_CPU_MAX_BUF_SHIFT config parameter, see below. Any higher size also might be forced by log_buf_len boot parameter.  Examples:            17 => 128 KB            16 => 64 KB            15 => 32 KB            14 => 16 KB            13 =>  8 KB            12 =>  4 KB
LOG_CPU_MAX_BUF_SHIFT;This option allows to increase the default ring buffer size according to the number of CPUs. The value defines the contribution of each CPU as a power of 2. The used space is typically only few lines however it might be much more when problems are reported, e.g. backtraces.  The increased size means that a new buffer has to be allocated and the original static one is unused. It makes sense only on systems with more CPUs. Therefore this value is used only when the sum of contributions is greater than the half of the default kernel ring buffer as defined by LOG_BUF_SHIFT. The default values are set so that more than 64 CPUs are needed to trigger the allocation.  Also this option is ignored when log_buf_len kernel parameter is used as it forces an exact (power of two) size of the ring buffer.  The number of possible CPUs is used for this computation ignoring hotplugging making the computation optimal for the worst case scenario while allowing a simple algorithm to be used from bootup.  Examples shift values and their meaning:            17 => 128 KB for each CPU            16 =>  64 KB for each CPU            15 =>  32 KB for each CPU            14 =>  16 KB for each CPU            13 =>   8 KB for each CPU            12 =>   4 KB for each CPU
PRINTK_SAFE_LOG_BUF_SHIFT;Select the size of an alternate printk per-CPU buffer where messages printed from usafe contexts are temporary stored. One example would be NMI messages, another one - printk recursion. The messages are copied to the main log buffer in a safe context to avoid a deadlock. The value defines the size as a power of 2.  Those messages are rare and limited. The largest one is when a backtrace is printed. It usually fits into 4KB. Select 8KB if you want to be on the safe side.  Examples:            17 => 128 KB for each CPU            16 =>  64 KB for each CPU            15 =>  32 KB for each CPU            14 =>  16 KB for each CPU            13 =>   8 KB for each CPU            12 =>   4 KB for each CPU
CHECKPOINT_RESTORE;Enables additional kernel features in a sake of checkpoint/restore. In particular it adds auxiliary prctl codes to setup process text, data and heap segment sizes, and a few additional /proc filesystem entries.  If unsure, say N here.
BLK_DEV_INITRD;The initial RAM filesystem is a ramfs which is loaded by the boot loader (loadlin or lilo) and that is mounted as root before the normal boot procedure. It is typically used to load modules needed to mount the real root file system, etc. See <file:Documentation/admin-guide/initrd.rst> for details.  If RAM disk support (BLK_DEV_RAM) is also included, this also enables initial RAM disk (initrd) support and adds 15 Kbytes (more on some other architectures) to the kernel size.  If unsure say Y.
INITRAMFS_COMPRESSION_BZIP2;It's compression ratio and speed is intermediate. Decompression speed is slowest among the choices. The initramfs size is about 10% smaller with bzip2, in comparison to gzip. Bzip2 uses a large amount of memory. For modern kernels you will need at least 8MB RAM or more for booting.  If you choose this, keep in mind that you need to have the bzip2 tool available to be able to compress the initram.
INITRAMFS_COMPRESSION_LZMA;This algorithm's compression ratio is best but has a large dictionary size which might cause issues in memory constrained systems. Decompression speed is between the other choices. Compression is slowest. The initramfs size is about 33% smaller with LZMA in comparison to gzip.  If you choose this, keep in mind that you may need to install the xz or lzma tools to be able to compress the initram.
INITRAMFS_COMPRESSION_XZ;XZ uses the LZMA2 algorithm and has a large dictionary which may cause problems on memory constrained systems. The initramfs size is about 30% smaller with XZ in comparison to gzip. Decompression speed is better than that of bzip2 but worse than gzip and LZO. Compression is slow.  If you choose this, keep in mind that you may need to install the xz tool to be able to compress the initram.
INITRAMFS_COMPRESSION_LZO;It's compression ratio is the second poorest amongst the choices. The kernel size is about 10% bigger than gzip. Despite that, it's decompression speed is the second fastest and it's compression speed is quite fast too.  If you choose this, keep in mind that you may need to install the lzop tool to be able to compress the initram.
INITRAMFS_COMPRESSION_LZ4;It's compression ratio is the poorest amongst the choices. The kernel size is about 15% bigger than gzip. however its decompression speed is the fastest.  If you choose this, keep in mind that most distros don't provide lz4 by default which could cause a build failure.
CC_OPTIMIZE_FOR_SIZE;Enabling this option will pass -Os instead of -O2 to your compiler resulting in a smaller kernel.  If unsure, say N.
POSIX_TIMERS;This includes native support for POSIX timers to the kernel. Some embedded systems have no use for them and therefore they can be configured out to reduce the size of the kernel image.  When this option is disabled, the following syscalls won't be available: timer_create, timer_gettime: timer_getoverrun, timer_settime, timer_delete, clock_adjtime, getitimer, setitimer, alarm. Furthermore, the clock_settime, clock_gettime, clock_getres and clock_nanosleep syscalls will be limited to CLOCK_REALTIME, CLOCK_MONOTONIC and CLOCK_BOOTTIME only.  If unsure say y.
KALLSYMS;Say Y here to let the kernel print out symbolic crash information and symbolic stack backtraces. This increases the size of the kernel somewhat, as all symbols have to be loaded into the kernel image.
KALLSYMS_ALL;Normally kallsyms only contains the symbols of functions for nicer OOPS messages and backtraces (i.e., symbols from the text and inittext sections). This is sufficient for most cases. And only in very rare cases (e.g., when a debugger is used) all symbols are required (e.g., names of variables from the data sections, etc).  This option makes sure that all symbols are loaded into the kernel image (i.e., symbols from all sections) in cost of increased kernel size (depending on the kernel configuration, it may be 300KiB or something like this).  Say N unless you really need all symbols.
KALLSYMS_BASE_RELATIVE;Instead of emitting them as absolute values in the native word size, emit the symbol references in the kallsyms table as 32-bit entries, each containing a relative value in the range [base, base + U32_MAX] or, when KALLSYMS_ABSOLUTE_PERCPU is in effect, each containing either an absolute value in the range [0, S32_MAX] or a relative value in the range [base, base + S32_MAX], where base is the lowest relative symbol address encountered in the image.  On 64-bit builds, this reduces the size of the address table by 50%, but more importantly, it results in entries whose values are build time constants, and no relocation pass is required at runtime to fix up the entries based on the runtime load address of the kernel.
BUG;Disabling this option eliminates support for BUG and WARN, reducing the size of your kernel image and potentially quietly ignoring numerous fatal conditions. You should only consider disabling this option for embedded systems with no facilities for reporting errors. Just say Y.
BASE_FULL;Disabling this option reduces the size of miscellaneous core kernel data structures. This saves memory on small machines, but may reduce performance.
SLUB_DEBUG;SLUB has extensive debug support features. Disabling these can result in significant savings in code size. This also disables SLUB sysfs support. /sys/slab will not exist and there will be no support for cache validation etc.
SLAB_MERGE_DEFAULT;For reduced kernel memory fragmentation, slab caches can be merged when they share the same size and other characteristics. This carries a risk of kernel heap overflows being able to overwrite objects from merged caches (and more easily control cache layout), which makes such heap attacks easier to exploit by attackers. By keeping caches unmerged, these kinds of exploits can usually only damage objects in the same cache. To disable merging at runtime, slab_nomerge can be passed on the kernel command line.
MODULE_SIG;Check modules for valid signatures upon load: the signature is simply appended to the module. For more information see Documentation/module-signing.txt.  Note that this option adds the OpenSSL development packages as a kernel build dependency so that the signing tool can use its crypto library.  !!!WARNING!!!  If you enable this option, you MUST make sure that the module DOES NOT get stripped after being signed.  This includes the debuginfo strip done by some packagers (such as rpmbuild) and inclusion into an initramfs that wants the module size reduced.
TRIM_UNUSED_KSYMS;The kernel and some modules make many symbols available for other modules to use via EXPORT_SYMBOL() and variants. Depending on the set of modules being selected in your kernel configuration, many of those exported symbols might never be used.  This option allows for unused exported symbols to be dropped from the build. In turn, this provides the compiler more opportunities (especially when using LTO) for optimizing the code and reducing binary size.  This might have some security advantages as well.  If unsure, or if you need to build out-of-tree modules, say N.
LBDAF;Enable block devices or files of size 2TB and larger.  This option is required to support the full capacity of large (2TB+) block devices, including RAID, disk, Network Block Device, Logical Volume Manager (LVM) and loopback.  This option also enables support for single files larger than 2TB.  The ext4 filesystem requires that this feature be enabled in order to support filesystems that have the huge_file feature enabled.  Otherwise, it will refuse to mount in the read-write mode any filesystems that use the huge_file feature, which is enabled by default by mke2fs.ext4.  The GFS2 filesystem also requires this feature.  If unsure, say Y.
NOMMU_INITIAL_TRIM_EXCESS;The NOMMU mmap() frequently needs to allocate large contiguous chunks of memory on which to store mappings, but it can only ask the system allocator for chunks in 2^N*PAGE_SIZE amounts - which is frequently more than it requires.  To deal with this, mmap() is able to trim off the excess and return it to the allocator.  If trimming is enabled, the excess is trimmed off and returned to the system allocator, which can cause extra fragmentation, particularly if there are a lot of transient processes.  If trimming is disabled, the excess is kept, but not used, which for long-term mappings means that the space is wasted.  Trimming can be dynamically controlled through a sysctl option (/proc/sys/vm/nr_trim_pages) which specifies the minimum number of excess pages there must be before trimming should occur, or zero if no trimming is to occur.  This option specifies the initial value of this option.  The default of 1 says that all excess pages should be trimmed.  See Documentation/nommu-mmap.txt for more information.
THP_SWAP;Swap transparent huge pages in one piece, without splitting. XXX: For now this only does clustered swap space allocation.  For selection by architectures with reasonable THP sizes.
CLEANCACHE;Cleancache can be thought of as a page-granularity victim cache for clean pages that the kernel's pageframe replacement algorithm (PFRA) would like to keep around, but can't since there isn't enough memory.  So when the PFRA evicts a page, it first attempts to use cleancache code to put the data contained in that page into transcendent memory, memory that is not directly accessible or addressable by the kernel and is of unknown and possibly time-varying size.  And when a cleancache-enabled filesystem wishes to access a page in a file on disk, it first checks cleancache to see if it already contains it. if it does, the page is copied into the kernel and a disk access is avoided. When a transcendent memory driver is available (such as zcache or Xen transcendent memory), a significant I/O reduction may be achieved.  When none is available, all cleancache calls are reduced to a single pointer-compare-against-NULL resulting in a negligible performance hit.  If unsure, say Y to enable cleancache
FRONTSWAP;Frontswap is so named because it can be thought of as the opposite of a backing store for a swap device.  The data is stored into transcendent memory, memory that is not directly accessible or addressable by the kernel and is of unknown and possibly time-varying size.  When space in transcendent memory is available, a significant swap I/O reduction may be achieved.  When none is available, all frontswap calls are reduced to a single pointer- compare-against-NULL resulting in a negligible performance hit and swap data is stored as normal on the matching swap device.  If unsure, say Y to enable frontswap.
MAX_STACK_SIZE_MB;This is the maximum stack size in Megabytes in the VM layout of 32-bit user processes when the stack grows upwards (currently only on parisc and metag arch). The stack will be located at the highest memory address minus the given value, unless the RLIMIT_STACK hard limit is changed to a smaller value in which case that is used.  A sane initial value is 80 MB.
NETFILTER_XT_TARGET_TCPMSS;This option adds a `TCPMSS' target, which allows you to alter the MSS value of TCP SYN packets, to control the maximum size for that connection (usually limiting it to your outgoing interface's MTU minus 40).  This is used to overcome criminally braindead ISPs or servers which block ICMP Fragmentation Needed packets.  The symptoms of this problem are that everything works fine from your Linux firewall/router, but machines behind it can never exchange large packets:       1) Web browsers connect, then hang with no data received.       2) Small mail works fine, but large emails hang.       3) ssh works fine, but scp hangs after initial handshaking.  Workaround: activate this option and add a rule to your firewall configuration like:  iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN \                -j TCPMSS --clamp-mss-to-pmtu  To compile it as a module, choose M here.  If unsure, say N.
NETFILTER_XT_MATCH_TCPMSS;This option adds a `tcpmss' match, which allows you to examine the MSS value of TCP SYN packets, which control the maximum packet size for that connection.  To compile it as a module, choose M here.  If unsure, say N.
IP_VS_TAB_BITS;The IPVS connection hash table uses the chaining scheme to handle hash collisions. Using a big IPVS connection hash table will greatly reduce conflicts when there are hundreds of thousands of connections in the hash table.  Note the table size must be power of 2. The table size will be the value of 2 to the your input number power. The number to choose is from 8 to 20, the default number is 12, which means the table size is 4096. Don't input the number too small, otherwise you will lose performance on it. You can adapt the table size yourself, according to your virtual server application. It is good to set the table size not far less than the number of connections per second multiplying average lasting time of connection in the table.  For example, your virtual server gets 200 connections per second, the connection lasts for 200 seconds in average in the connection table, the table size should be not far less than 200x200, it is good to set the table size 32768 (2**15).  Another note that each connection occupies 128 bytes effectively and each hash entry uses 8 bytes, so you can estimate how much memory is needed for your box.  You can overwrite this number setting conn_tab_bits module parameter or by appending ip_vs.conn_tab_bits=? to the kernel command line if IP VS was compiled built-in.
IP_SCTP;Stream Control Transmission Protocol  From RFC 2960 <http://www.ietf.org/rfc/rfc2960.txt>.  SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP.  It offers the following services to its users:  -- acknowledged error-free non-duplicated transfer of user data, -- data fragmentation to conform to discovered path MTU size, -- sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages, -- optional bundling of multiple user messages into a single SCTP packet, and -- network-level fault tolerance through supporting of multi- homing at either or both ends of an association.  To compile this protocol support as a module, choose M here: the module will be called sctp. Debug messages are handeled by the kernel's dynamic debugging framework.  If in doubt, say N.
ATM;ATM is a high-speed networking technology for Local Area Networks and Wide Area Networks.  It uses a fixed packet size and is connection oriented, allowing for the negotiation of minimum bandwidth requirements.  In order to participate in an ATM network, your Linux box needs an ATM networking card. If you have that, say Y here and to the driver of your ATM card below.  Note that you need a set of user-space programs to actually make use of ATM.  See the file <file:Documentation/networking/atm.txt> for further details.
BRIDGE_IGMP_SNOOPING;If you say Y here, then the Ethernet bridge will be able selectively forward multicast traffic based on IGMP/MLD traffic received from each port.  Say N to exclude this support and reduce the binary size.  If unsure, say Y.
BRIDGE_VLAN_FILTERING;If you say Y here, then the Ethernet bridge will be able selectively receive and forward traffic based on VLAN information in the packet any VLAN information configured on the bridge port or bridge device.  Say N to exclude this support and reduce the binary size.  If unsure, say Y.
NET_EMATCH_STACK;Size of the local stack variable used while evaluating the tree of ematches. Limits the depth of the tree, i.e. the number of encapsulated precedences. Every level requires 4 bytes of additional stack space.
OPENVSWITCH_GRE;If you say Y here, then the Open vSwitch will be able create GRE vport.  Say N to exclude this support and reduce the binary size.  If unsure, say Y.
OPENVSWITCH_VXLAN;If you say Y here, then the Open vSwitch will be able create vxlan vport.  Say N to exclude this support and reduce the binary size.  If unsure, say Y.
OPENVSWITCH_GENEVE;If you say Y here, then the Open vSwitch will be able create geneve vport.  Say N to exclude this support and reduce the binary size.
MAC80211_NOINLINE;This option affects code generation in mac80211, when selected some functions are marked noinline to allow easier debugging of problems in the transmit and receive paths.  This option increases code size a bit and inserts a lot of function calls in the code, but is otherwise safe to enable.  If unsure, say N unless you expect to be finding problems in mac80211.
MAC80211_STA_HASH_MAX_SIZE;Setting this option to a low value (e.g. 4) allows testing the hash table with collisions relatively deterministically (just connect more stations than the number selected here.)  If unsure, leave the default of 0.
CEPH_LIB_PRETTYDEBUG;If you say Y here, debug output will include a filename and line to aid debugging.  This increases kernel size and slows execution slightly when debug call sites are enabled (e.g., via CONFIG_DYNAMIC_DEBUG).  If unsure, say N.
EXT4_USE_FOR_EXT2;Allow the ext4 file system driver code to be used for ext2 file system mounts.  This allows users to reduce their compiled kernel size by using one file system driver for ext2, ext3, and ext4 file systems.
XFS_FS;XFS is a high performance journaling filesystem which originated on the SGI IRIX platform.  It is completely multi-threaded, can support large files and large filesystems, extended attributes, variable block sizes, is extent based, and makes extensive use of Btrees (directories, extents, free space) to aid both performance and scalability.  Refer to the documentation at <http://oss.sgi.com/projects/xfs/> for complete details.  This implementation is on-disk compatible with the IRIX version of XFS.  To compile this file system support as a module, choose M here: the module will be called xfs.  Be aware, however, that if the file system of your root partition is compiled as a module, you'll need to use an initial ramdisk (initrd) to boot.
FS_DAX;Direct Access (DAX) can be used on memory-backed block devices. If the block device supports DAX and the filesystem supports DAX, then you can avoid using the pagecache to buffer I/Os.  Turning on this option will compile in support for DAX. you will need to mount the filesystem using the -o dax option.  If you do not have a block device that is capable of using this, or if unsure, say N.  Saying Y will increase the size of the kernel by about 5kB.
NTFS_FS;NTFS is the file system of Microsoft Windows NT, 2000, XP and 2003.  Saying Y or M here enables read support.  There is partial, but safe, write support available.  For write support you must also say Y to NTFS write support below.  There are also a number of user-space tools available, called ntfsprogs.  These include ntfsundelete and ntfsresize, that work without NTFS support enabled in the kernel.  This is a rewrite from scratch of Linux NTFS support and replaced the old NTFS code starting with Linux 2.5.11.  A backport to the Linux 2.4 kernel series is separately available as a patch from the project web site.  For more information see <file:Documentation/filesystems/ntfs.txt> and <http://www.linux-ntfs.org/>.  To compile this file system support as a module, choose M here: the module will be called ntfs.  If you are not using Windows NT, 2000, XP or 2003 in addition to Linux on your computer it is safe to say N.
PROC_PAGE_MONITOR;Various /proc files exist to monitor process memory utilization: /proc/pid/smaps, /proc/pid/clear_refs, /proc/pid/pagemap, /proc/kpagecount, and /proc/kpageflags. Disabling these interfaces will reduce the size of the kernel by approximately 4kb.
EFIVAR_FS;efivarfs is a replacement filesystem for the old EFI variable support via sysfs, as it doesn't suffer from the same 1024-byte variable size limit.  To compile this file system support as a module, choose M here. The module will be called efivarfs.  If unsure, say N.
JFFS2_CMODE_SIZE;Tries all compressors and chooses the one which has the smallest result.
JFFS2_CMODE_FAVOURLZO;Tries all compressors and chooses the one which has the smallest result but gives some preference to LZO (which has faster decompression) at the expense of size.
SQUASHFS;Saying Y here includes support for SquashFS 4.0 (a Compressed Read-Only File System).  Squashfs is a highly compressed read-only filesystem for Linux.  It uses zlib, lzo or xz compression to compress both files, inodes and directories.  Inodes in the system are very small and all blocks are packed to minimise data overhead. Block sizes greater than 4K are supported up to a maximum of 1 Mbytes (default block size 128K).  SquashFS 4.0 supports 64 bit filesystems and files (larger than 4GB), full uid/gid information, hard links and timestamps.  Squashfs is intended for general read-only filesystem use, for archival use (i.e. in cases where a .tar.gz file may be used), and in embedded systems where low overhead is needed.  Further information and tools are available from http://squashfs.sourceforge.net.  If you want to compile this as a module ( = code which can be inserted in and removed from the running kernel whenever you want), say M here.  The module will be called squashfs.  Note that the root file system (the one containing the directory /) cannot be compiled as a module.  If unsure, say N.
SQUASHFS_4K_DEVBLK_SIZE;By default Squashfs sets the dev block size (sb_min_blocksize) to 1K or the smallest block size supported by the block device (if larger).  This, because blocks are packed together and unaligned in Squashfs, should reduce latency.  This, however, gives poor performance on MTD NAND devices where the optimal I/O size is 4K (even though the devices can support smaller block sizes).  Using a 4K device block size may also improve overall I/O performance for some file access patterns (e.g. sequential accesses of files in filesystem order) on all media.  Setting this option will force Squashfs to use a 4K device block size by default.  If unsure, say N.
SQUASHFS_EMBEDDED;Saying Y here allows you to specify cache size.  If unsure, say N.
SQUASHFS_FRAGMENT_CACHE_SIZE;By default SquashFS caches the last 3 fragments read from the filesystem.  Increasing this amount may mean SquashFS has to re-read fragments less often from disk, at the expense of extra system memory.  Decreasing this amount will mean SquashFS uses less memory at the expense of extra reads from disk.  Note there must be at least one cached fragment.  Anything much more than three will probably not make much difference.
CIFS_DEBUG;Enabling this option adds helpful debugging messages to the cifs code which increases the size of the cifs module. If unsure, say Y.
CIFS_DEBUG2;Enabling this option adds a few more debugging routines to the cifs code which slightly increases the size of the cifs module and can cause additional logging of debug messages in some error paths, slowing performance. This option can be turned off unless you are debugging cifs problems.  If unsure, say N.
HAVE_HARDENED_USERCOPY_ALLOCATOR;The heap allocator implements __check_heap_object() for validating memory ranges against heap object sizes in support of CONFIG_HARDENED_USERCOPY.
FORTIFY_SOURCE;Detect overflows of buffers in common string and memory functions where the compiler can determine and validate the buffer sizes.
CRYPTO_XTS;XTS: IEEE1619/D16 narrow block cipher use with aes-xts-plain, key size 256, 384 or 512 bits. This implementation currently can't handle a sectorsize which is not a multiple of 16 bytes.
CRYPTO_AES;AES cipher algorithms (FIPS-197). AES uses the Rijndael algorithm.  Rijndael appears to be consistently a very good performer in both hardware and software across a wide range of computing environments regardless of its use in feedback or non-feedback modes. Its key setup time is excellent, and its key agility is good. Rijndael's very low memory requirements make it very well suited for restricted-space environments, in which it also demonstrates excellent performance. Rijndael's operations are among the easiest to defend against power and timing attacks.  The AES specifies three key sizes: 128, 192 and 256 bits  See <http://csrc.nist.gov/CryptoToolkit/aes/> for more information.
CRYPTO_AES_586;AES cipher algorithms (FIPS-197). AES uses the Rijndael algorithm.  Rijndael appears to be consistently a very good performer in both hardware and software across a wide range of computing environments regardless of its use in feedback or non-feedback modes. Its key setup time is excellent, and its key agility is good. Rijndael's very low memory requirements make it very well suited for restricted-space environments, in which it also demonstrates excellent performance. Rijndael's operations are among the easiest to defend against power and timing attacks.  The AES specifies three key sizes: 128, 192 and 256 bits  See <http://csrc.nist.gov/encryption/aes/> for more information.
CRYPTO_AES_X86_64;AES cipher algorithms (FIPS-197). AES uses the Rijndael algorithm.  Rijndael appears to be consistently a very good performer in both hardware and software across a wide range of computing environments regardless of its use in feedback or non-feedback modes. Its key setup time is excellent, and its key agility is good. Rijndael's very low memory requirements make it very well suited for restricted-space environments, in which it also demonstrates excellent performance. Rijndael's operations are among the easiest to defend against power and timing attacks.  The AES specifies three key sizes: 128, 192 and 256 bits  See <http://csrc.nist.gov/encryption/aes/> for more information.
CRYPTO_AES_NI_INTEL;Use Intel AES-NI instructions for AES algorithm.  AES cipher algorithms (FIPS-197). AES uses the Rijndael algorithm.  Rijndael appears to be consistently a very good performer in both hardware and software across a wide range of computing environments regardless of its use in feedback or non-feedback modes. Its key setup time is excellent, and its key agility is good. Rijndael's very low memory requirements make it very well suited for restricted-space environments, in which it also demonstrates excellent performance. Rijndael's operations are among the easiest to defend against power and timing attacks.  The AES specifies three key sizes: 128, 192 and 256 bits  See <http://csrc.nist.gov/encryption/aes/> for more information.  In addition to AES cipher algorithm support, the acceleration for some popular block cipher mode is supported too, including ECB, CBC, LRW, PCBC, XTS. The 64 bit version has additional acceleration for CTR.
CRYPTO_AES_SPARC64;Use SPARC64 crypto opcodes for AES algorithm.  AES cipher algorithms (FIPS-197). AES uses the Rijndael algorithm.  Rijndael appears to be consistently a very good performer in both hardware and software across a wide range of computing environments regardless of its use in feedback or non-feedback modes. Its key setup time is excellent, and its key agility is good. Rijndael's very low memory requirements make it very well suited for restricted-space environments, in which it also demonstrates excellent performance. Rijndael's operations are among the easiest to defend against power and timing attacks.  The AES specifies three key sizes: 128, 192 and 256 bits  See <http://csrc.nist.gov/encryption/aes/> for more information.  In addition to AES cipher algorithm support, the acceleration for some popular block cipher mode is supported too, including ECB and CBC.
CRYPTO_AES_PPC_SPE;AES cipher algorithms (FIPS-197). Additionally the acceleration for popular block cipher modes ECB, CBC, CTR and XTS is supported. This module should only be used for low power (router) devices without hardware AES acceleration (e.g. caam crypto). It reduces the size of the AES tables from 16KB to 8KB + 256 bytes and mitigates timining attacks. Nevertheless it might be not as secure as other architecture specific assembler implementations that work on 1KB tables or 256 bytes S-boxes.
CRYPTO_CAMELLIA;Camellia cipher algorithms module.  Camellia is a symmetric key block cipher developed jointly at NTT and Mitsubishi Electric Corporation.  The Camellia specifies three key sizes: 128, 192 and 256 bits.  See also: <https://info.isl.ntt.co.jp/crypt/eng/camellia/index_s.html>
CRYPTO_CAMELLIA_X86_64;Camellia cipher algorithm module (x86_64).  Camellia is a symmetric key block cipher developed jointly at NTT and Mitsubishi Electric Corporation.  The Camellia specifies three key sizes: 128, 192 and 256 bits.  See also: <https://info.isl.ntt.co.jp/crypt/eng/camellia/index_s.html>
CRYPTO_CAMELLIA_AESNI_AVX_X86_64;Camellia cipher algorithm module (x86_64/AES-NI/AVX).  Camellia is a symmetric key block cipher developed jointly at NTT and Mitsubishi Electric Corporation.  The Camellia specifies three key sizes: 128, 192 and 256 bits.  See also: <https://info.isl.ntt.co.jp/crypt/eng/camellia/index_s.html>
CRYPTO_CAMELLIA_AESNI_AVX2_X86_64;Camellia cipher algorithm module (x86_64/AES-NI/AVX2).  Camellia is a symmetric key block cipher developed jointly at NTT and Mitsubishi Electric Corporation.  The Camellia specifies three key sizes: 128, 192 and 256 bits.  See also: <https://info.isl.ntt.co.jp/crypt/eng/camellia/index_s.html>
CRYPTO_CAMELLIA_SPARC64;Camellia cipher algorithm module (SPARC64).  Camellia is a symmetric key block cipher developed jointly at NTT and Mitsubishi Electric Corporation.  The Camellia specifies three key sizes: 128, 192 and 256 bits.  See also: <https://info.isl.ntt.co.jp/crypt/eng/camellia/index_s.html>
CRYPTO_KHAZAD;Khazad cipher algorithm.  Khazad was a finalist in the initial NESSIE competition.  It is an algorithm optimized for 64-bit processors with good performance on 32-bit processors.  Khazad uses an 128 bit key size.  See also: <http://www.larc.usp.br/~pbarreto/KhazadPage.html>
CRYPTO_SEED;SEED cipher algorithm (RFC4269).  SEED is a 128-bit symmetric key block cipher that has been developed by KISA (Korea Information Security Agency) as a national standard encryption algorithm of the Republic of Korea. It is a 16 round block cipher with the key size of 128 bit.  See also: <http://www.kisa.or.kr/kisa/seed/jsp/seed_eng.jsp>
CRYPTO_TWOFISH;Twofish cipher algorithm.  Twofish was submitted as an AES (Advanced Encryption Standard) candidate cipher by researchers at CounterPane Systems.  It is a 16 round block cipher supporting key sizes of 128, 192, and 256 bits.  See also: <http://www.schneier.com/twofish.html>
CRYPTO_TWOFISH_586;Twofish cipher algorithm.  Twofish was submitted as an AES (Advanced Encryption Standard) candidate cipher by researchers at CounterPane Systems.  It is a 16 round block cipher supporting key sizes of 128, 192, and 256 bits.  See also: <http://www.schneier.com/twofish.html>
CRYPTO_TWOFISH_X86_64;Twofish cipher algorithm (x86_64).  Twofish was submitted as an AES (Advanced Encryption Standard) candidate cipher by researchers at CounterPane Systems.  It is a 16 round block cipher supporting key sizes of 128, 192, and 256 bits.  See also: <http://www.schneier.com/twofish.html>
CRYPTO_TWOFISH_X86_64_3WAY;Twofish cipher algorithm (x86_64, 3-way parallel).  Twofish was submitted as an AES (Advanced Encryption Standard) candidate cipher by researchers at CounterPane Systems.  It is a 16 round block cipher supporting key sizes of 128, 192, and 256 bits.  This module provides Twofish cipher algorithm that processes three blocks parallel, utilizing resources of out-of-order CPUs better.  See also: <http://www.schneier.com/twofish.html>
CRYPTO_TWOFISH_AVX_X86_64;Twofish cipher algorithm (x86_64/AVX).  Twofish was submitted as an AES (Advanced Encryption Standard) candidate cipher by researchers at CounterPane Systems.  It is a 16 round block cipher supporting key sizes of 128, 192, and 256 bits.  This module provides the Twofish cipher algorithm that processes eight blocks parallel using the AVX Instruction Set.  See also: <http://www.schneier.com/twofish.html>
SYSTEM_EXTRA_CERTIFICATE_SIZE;This is the number of bytes reserved in the kernel image for a certificate to be inserted.
FONT_6x10;Medium-size console font. Suitable for framebuffer consoles on embedded devices with a 320x240 screen, to get a reasonable number of characters (53x24) that are still at a readable size.
CMDLINE;If you don't have a boot loader capable of passing a command line string to the kernel, you may specify one here. As a minimum, you should specify the memory size and the root device (e.g., mem=8M, root=/dev/nfs).
FORCE_MAX_ZONEORDER;The kernel memory allocator divides physically contiguous memory blocks into zones, where each zone is a power of two number of pages.  This option selects the largest power of two that the kernel keeps in the memory allocator.  If you need to allocate very large blocks of physically contiguous memory, then you may need to increase this value.  This config option is actually maximum order plus one. For example, a value of 11 means that the largest free memory block is 2^10 pages.  We make sure that we can allocate upto a HugePage size for each configuration. Hence we have :       MAX_ORDER = (PMD_SHIFT - PAGE_SHIFT) + 1 => PAGE_SHIFT - 2  However for 4K, we choose a higher default value, 11 as opposed to 10, giving us 4M allocations matching the default size used by generic code.
NIOS2_DCACHE_SIZE;Maximum possible data cache size.
NIOS2_DCACHE_LINE_SIZE;Minimum possible data cache line size.
NIOS2_ICACHE_SIZE;Maximum possible instruction cache size.
COMPAT;This option enables support for a 32-bit EL0 running under a 64-bit kernel at EL1. AArch32-specific components such as system calls, the user helper functions, VFP support and the ptrace interface are handled appropriately by the kernel.  If you use a page size other than 4KB (i.e, 16KB or 64KB), please be aware that you will only be able to execute AArch32 binaries that were compiled with page size aligned segments.  If you want to execute 32-bit userspace applications, say Y.
EMU_SIZE;Select the default size by which the memory is chopped and then assigned to emulated NUMA nodes.  This can be overridden by specifying  emu_size=<n>  on the kernel command line where also suffixes K, M, G, and T are supported.
MAX_PHYSMEM_BITS;This option specifies the maximum supported size of physical memory in bits. Supported is any size between 2^42 (4TB) and 2^53 (8PB). Increasing the number of bits also increases the kernel image size. By default 46 bits (64TB) are supported.
PACK_STACK;This option enables the compiler option -mkernel-backchain if it is available. If the option is available the compiler supports the new stack layout which dramatically reduces the minimum stack frame size. With an old compiler a non-leaf function needs a minimum of 96 bytes on 31 bit and 160 bytes on 64 bit. With -mkernel-backchain the minimum size drops to 16 byte on 31 bit and 24 byte on 64 bit.  Say Y if you are unsure.
CHECK_STACK;This option enables the compiler option -mstack-guard and -mstack-size if they are available. If the compiler supports them it will emit additional code to each function prolog to trigger an illegal operation if the kernel stack is about to overflow.  Say N if you are unsure.
STACK_GUARD;This allows you to specify the size of the guard area at the lower end of the kernel stack. If the kernel stack points into the guard area on function entry an illegal operation is triggered. The size needs to be a power of 2. Please keep in mind that the size of an interrupt frame is 184 bytes for 31 bit and 328 bytes on 64 bit. The minimum size for the stack guard should be 256 for 31 bit and 512 for 64 bit.
SHARED_KERNEL;Select this option, if you want to share the text segment of the Linux kernel between different VM guests. This reduces memory usage with lots of guests but greatly increases kernel size. Also if a kernel was IPL'ed from a shared segment the kexec system call will not work. You should only select this option if you know what you are doing and want to exploit this feature.
CMM;Select this option, if you want to enable the kernel interface to reduce the memory size of the system. This is accomplished by allocating pages of memory and put them on hold. This only makes sense for a system running in an LPAR where the unused pages will be reused for other LPARs. The interface allows firmware to balance memory across many LPARs.
MPENTIUM4;Select this for Intel Pentium 4 chips.  This includes the Pentium 4, Pentium D, P4-based Celeron and Xeon, and Pentium-4 M (not Pentium M) chips.  This option enables compile flags optimized for the chip, uses the correct cache line size, and applies any applicable optimizations.  CPUIDs: F[0-6][1-A] (in /proc/cpuinfo show = cpu family : 15 )  Select this for:   Pentiums (Pentium 4, Pentium D, Celeron, Celeron D) corename:       -Willamette       -Northwood       -Mobile Pentium 4       -Mobile Pentium 4 M       -Extreme Edition (Gallatin)       -Prescott       -Prescott 2M       -Cedar Mill       -Presler       -Smithfiled   Xeons (Intel Xeon, Xeon MP, Xeon LV, Xeon MV) corename:       -Foster       -Prestonia       -Gallatin       -Nocona       -Irwindale       -Cranford       -Potomac       -Paxville       -Dempsey
LGUEST_GUEST;Lguest is a tiny in-kernel hypervisor.  Selecting this will allow your kernel to boot under lguest.  This option will increase your kernel size by about 10k.  If in doubt, say N.  If you say Y here, make sure you say Y (or M) to the virtio block and net drivers which lguest needs.
SWIOTLB;Support for IO bounce buffering for systems without an IOMMU. This allows us to DMA to the full physical address space on platforms where the size of a physical address is larger than the bus address.  Not all platforms support this.
X86_VSYSCALL_EMULATION;This enables emulation of the legacy vsyscall page.  Disabling it is roughly equivalent to booting with vsyscall=none, except that it will also disable the helpful warning if a program tries to use a vsyscall.  With this option set to N, offending programs will just segfault, citing addresses of the form 0xffffffffff600?00.  This option is required by many programs built before 2013, and care should be used even with newer programs if set to N.  Disabling this option saves about 7K of kernel size and possibly 4K of additional runtime pagetable memory.
X86_CHECK_BIOS_CORRUPTION;Periodically check for memory corruption in low memory, which is suspected to be caused by BIOS.  Even when enabled in the configuration, it is disabled at runtime.  Enable it by setting memory_corruption_check=1 on the kernel command line.  By default it scans the low 64k of memory every 60 seconds. see the memory_corruption_check_size and memory_corruption_check_period parameters in Documentation/admin-guide/kernel-parameters.rst to adjust this.  When enabled with the default parameters, this option has almost no overhead, as it reserves a relatively small amount of memory and scans it infrequently.  It both detects corruption and prevents it from affecting the running system.  It is, however, intended as a diagnostic tool. if repeatable BIOS-originated corruption always affects the same memory, you can use memmap= to prevent the kernel from using that memory.
MTRR_SANITIZER;Convert MTRR layout from continuous to discrete, so X drivers can add writeback entries.  Can be disabled with disable_mtrr_cleanup on the kernel command line. The largest mtrr entry size for a continuous block can be set with mtrr_chunk_size.  If unsure, say Y.
X86_SMAP;Supervisor Mode Access Prevention (SMAP) is a security feature in newer Intel processors.  There is a small performance cost if this enabled and turned on. there is also a small increase in the kernel size if this is enabled.  If unsure, say Y.
RANDOMIZE_MEMORY_PHYSICAL_PADDING;Define the padding in terabytes added to the existing physical memory size during kernel memory randomization. It is useful for memory hotplug support but reduces the entropy available for address randomization.  If unsure, leave at the default value.
KERNEL_STACK_ORDER;This option determines the size of UML kernel stacks.  They will be 1 << order pages.  The default is OK unless you're running Valgrind on UML, in which case, set this to 3.
PPC_MEMCONS_OUTPUT_SIZE;Selects the size of the output buffer (in bytes) of the in memory console.
PPC_MEMCONS_INPUT_SIZE;Selects the size of the input buffer (in bytes) of the in memory console.
PS3_HTAB_SIZE;This option is only for experts who may have the desire to fine tune the pagetable size on their system.  The value here is expressed as the log2 of the page table size.  Valid values are 18, 19, and 20, corresponding to 256KB, 512KB and 1MB respectively.  If unsure, choose the default (20) with the confidence that your system will have optimal runtime performance.
PS3_REPOSITORY_WRITE;Enables support for writing to the PS3 System Repository.  This support is intended for bootloaders that need to store data in the repository for later boot stages.  If in doubt, say N here and reduce the size of the kernel by a small amount.
FSL_85XX_CACHE_SRAM;When selected, this option enables cache-sram support for memory allocation on P1/P2 QorIQ platforms. cache-sram-size and cache-sram-offset kernel boot parameters should be passed when this option is enabled.
STDBINUTILS;Turning this option off allows you to select 256KB PAGE_SIZE on 44x. Note, that kernel will be able to run only those applications, which had been compiled using binutils later than 2.17.50.0.3 with '-zmax-page-size' set to 256K (the default is 64K). Or, if using the older binutils, you can patch them with a trivial patch, which changes the ELF_MAXPAGESIZE definition from 0x10000 to 0x40000.
PPC_256K_PAGES;Make the page size 256k.  As the ELF standard only requires alignment to support page sizes up to 64k, you will need to compile all of your user space applications with a non-standard binutils settings (see the STDBINUTILS description for details).  Say N unless you know what you are doing.
THREAD_SHIFT;Used to define the stack size. The default is almost always what you want. Only change this if you know what you are doing.
LOWMEM_SIZE_BOOL;This option allows you to set the maximum amount of memory which will be used as low memory, that is, memory which the kernel can access directly, without having to set up a kernel virtual mapping. This can be useful in optimizing the layout of kernel virtual memory.  Say N here unless you know what you are doing.
DYNAMIC_MEMSTART;This option enables the kernel to be loaded at any page aligned physical address. The kernel creates a mapping from KERNELBASE to  the address where the kernel is loaded. The page size here implies the TLB page size of the mapping for kernel on the particular platform. Please refer to the init code for finding the TLB page size.  DYNAMIC_MEMSTART is an easy way of implementing pseudo-RELOCATABLE kernel image, where the only restriction is the page aligned kernel load address. When this option is enabled, the compile time physical  address CONFIG_PHYSICAL_START is ignored.  This option is overridden by CONFIG_RELOCATABLE
TASK_SIZE_BOOL;This option allows you to set the amount of virtual address space allocated to user tasks.  This can be useful in optimizing the virtual memory layout of the system.  Say N here unless you know what you are doing.
CONSISTENT_SIZE_BOOL;This option allows you to set the size of the consistent memory pool.  This pool of virtual memory is used to make consistent memory allocations.
LD_NO_RELAX;Enable this function to disable link-time optimizations. The default linker behavior is to combine identical literal values to reduce code size and remove unnecessary overhead from assembler-generated 'longcall' sequences. Enabling this option improves the link time but increases the code size, and possibly execution time.
DEFAULT_MEM_SIZE;This is the size of the default memory area. Default memory area has platform-specific meaning, it may be used for e.g. early cache initialization.  If unsure, leave the default value here.
4KSTACKS;If you say Y here the kernel will use a 4Kb stacksize for the kernel stack attached to each process/thread. This facilitates running more threads on a system and also reduces the pressure on the VM subsystem for higher order allocations.
DUMP_CODE;This prints out a code trace of the instructions leading up to the faulting instruction as a debugging aid. As this does grow the kernel in size a bit, most users will want to say N here.  Those looking for more verbose debugging output should say Y.
DWARF_UNWINDER;Enabling this option will make stacktraces more accurate, at the cost of an increase in overall kernel size.
MEMORY_SIZE;This sets the default memory size assumed by your SH kernel. It can be overridden as normal by the 'mem=' argument on the kernel command line. If unsure, consult your board specifications or just leave it as 0x04000000 which was the default value before this became configurable.
PAGE_SIZE_4KB;This option select the standard 4kB Linux page size.  On some R3000-family processors this is the only available page size.  Using 4kB page size will minimize memory consumption and is therefore recommended for low memory systems.
PAGE_SIZE_8KB;Using 8kB page size will result in higher performance kernel at the price of higher memory consumption.  This option is available only on R8000 and cnMIPS processors.  Note that you will need a suitable Linux distribution to support this.
PAGE_SIZE_16KB;Using 16kB page size will result in higher performance kernel at the price of higher memory consumption.  This option is available on all non-R3000 family processors.  Note that you will need a suitable Linux distribution to support this.
PAGE_SIZE_64KB;Using 64kB page size will result in higher performance kernel at the price of higher memory consumption.  This option is available on all non-R3000 family processor.  Not that at the time of this writing this option is still high experimental.
GDBSTUB;If you say Y here, it will be possible to remotely debug the kernel using gdb. This enlarges your kernel ELF image disk size by several megabytes and requires a machine with more than 16 MB, better 32 MB RAM to avoid excessive linking time. This is only useful for kernel hackers. If unsure, say N.  This is deprecated in favour of KGDB and will be removed in a later version.
16KSTACKS;If you say Y here the kernel will use a  16Kb stacksize for the kernel stack attached to each process/thread. The default is 8K. This increases the resident kernel footprint and will cause less threads to run on the system and also increase the pressure on the VM subsystem for higher order allocations.
ARC_MMU_V3;Introduced with ARC700 4.10: New Features Variable Page size (1k-16k), var JTLB size 128 x (2 or 4) Shared Address Spaces (SASID)
ARC_PAGE_SIZE_8K;Choose between 8k vs 16k
ARC_KVADDR_SIZE;The kernel address space is carved out of 256MB of translated address space for catering to vmalloc, modules, pkmap, fixmap. This however may not suffice vmalloc requirements of a 4K CPU EZChip system. So allow this to be stretched to 512 MB (by extending into the reserved kernel-user gutter)
PAGE_SIZE_4K;This is the default page size used by all Meta cores.
PAGE_SIZE_8K;This enables 8kB pages as supported by Meta 2.x and later MMUs.
PAGE_SIZE_16K;This enables 16kB pages as supported by Meta 2.x and later MMUs.
IA64_GRANULE_16MB;IA-64 identity-mapped regions use a large page size called granules.  Select 16MB for a small granule size. Select 64MB for a large granule size.  This is the current default.
IA64_PAGE_SIZE_4KB;This lets you select the page size of the kernel.  For best IA-64 performance, a page size of 8KB or 16KB is recommended.  For best IA-32 compatibility, a page size of 4KB should be selected (the vast majority of IA-32 binaries work perfectly fine with a larger page size).  For Itanium 2 or newer systems, a page size of 64KB can also be selected.  4KB                For best IA-32 compatibility 8KB                For best IA-64 performance 16KB               For best IA-64 performance 64KB               Requires Itanium 2 or newer processor.  If you don't know what to do, choose 16KB.
IA64_PALINFO;If you say Y here, you are able to get PAL (Processor Abstraction Layer) information in /proc/pal.  This contains useful information about the processors in your systems, such as cache and TLB sizes and the PAL firmware version in use.  To use this option, you have to ensure that the /proc file system support (CONFIG_PROC_FS) is enabled, too.
DEBUG_ZBOOT;If you want to add compressed kernel support to a new board, and the board supports uart16550 compatible serial port, please select SYS_SUPPORTS_ZBOOT_UART16550 for your board and enable this option to debug it.  If your board doesn't support uart16550 compatible serial port, you can try to select SYS_SUPPORTS_ZBOOT and use the other methods to debug it. for example, add a new serial port support just as arch/mips/boot/compressed/uart-16550.c does.  After the compressed kernel support works, please disable this option to reduce the kernel image size and speed up the booting procedure a little.
CAVIUM_OCTEON_CVMSEG_SIZE;CVMSEG LM is a segment that accesses portions of the dcache as a local memory. the larger CVMSEG is, the smaller the cache is. This selects the size of CVMSEG LM, which is in cache blocks. The legally range is from zero to 54 cache blocks (i.e. CVMSEG LM is between zero and 6192 bytes).
CPU_MIPS32_3_5_EVA;Choose this option if you want to enable the Enhanced Virtual Addressing (EVA) on your MIPS32 core (such as proAptiv). One of its primary benefits is an increase in the maximum size of lowmem (up to 3GB). If unsure, say 'N' here.
CPU_MIPS32_R5_XPA;Choose this option if you want to enable the Extended Physical Addressing (XPA) on your MIPS32 core (such as P5600 series). The benefit is to increase physical addressing equal to or greater than 40 bits. Note that this has the side effect of turning on 64-bit addressing which in turn makes the PTEs 64-bit in size. If unsure, say 'N' here.
MIPS_VA_BITS_48;Support a maximum at least 48 bits of application virtual memory.  Default is 40 bits or less, depending on the CPU. For page sizes 16k and above, this option results in a small memory overhead for page tables.  For 4k page size, a fourth level of page tables is added which imposes both a memory overhead as well as slower TLB fault handling.  If unsure, say N.
PAGE_SIZE_32KB;Using 32kB page size will result in higher performance kernel at the price of higher memory consumption.  This option is available only on cnMIPS cores.  Note that you will need a suitable Linux distribution to support this.
CPU_HAS_MSA;MIPS SIMD Architecture (MSA) introduces 128 bit wide vector registers and a set of SIMD instructions to operate on them. When this option is enabled the kernel will support allocating & switching MSA vector register contexts. If you know that your kernel will only be running on CPUs which do not support MSA or that your userland will not be making use of it then you may wish to say N here to reduce the size & complexity of your kernel.  If unsure, say Y.
RELOCATION_TABLE_SIZE;A table of relocation data will be appended to the kernel binary and parsed at boot to fix up the relocated kernel.  This option allows the amount of space reserved for the table to be adjusted, although the default of 1Mb should be ok in most cases.  The build will fail and a valid size suggested if this is too small.  If unsure, leave at the default value.
RANDOMIZE_BASE_MAX_OFFSET;When kASLR is active, this provides the maximum offset that will be applied to the kernel image. It should be set according to the amount of physical RAM available in the target system minus PHYSICAL_START and must be a power of 2.  This is limited by the size of KSEG0, 256Mb on 32-bit or 1Gb with EVA or 64-bit. The default is 16Mb.
MIPS_O32_FP64_SUPPORT;When this is enabled, the kernel will support use of 64-bit floating point registers with binaries using the O32 ABI along with the EF_MIPS_FP64 ELF header flag (typically built with -mfp64). On 32-bit MIPS systems this support is at the cost of increasing the size and complexity of the compiled FPU emulator. Thus if you are running a MIPS32 system and know that none of your userland binaries will require 64-bit floating point, you may wish to reduce the size of your kernel & potentially improve FP emulation performance by saying N here.  Although binutils currently supports use of this flag the details concerning its effect upon the O32 ABI in userland are still being worked on. In order to avoid userland becoming dependant upon current behaviour before the details have been finalised, this option should be considered experimental and only enabled by those working upon said details.  If unsure, say N.
ARM_DMA_IOMMU_ALIGNMENT;DMA mapping framework by default aligns all buffers to the smallest PAGE_SIZE order which is greater than or equal to the requested buffer size. This works well for buffers up to a few hundreds kilobytes, but for larger buffers it just a waste of address space. Drivers which has relatively small addressing window (like 64Mib) might run out of virtual space with just a few allocations.  With this parameter you can specify the maximum PAGE_SIZE order for DMA IOMMU buffers. Larger buffers will be aligned only to this specified order. The order is expressed as a power of two multiplied by the PAGE_SIZE.
VECTORS_BASE;The base address of exception vectors.  This must be two pages in size.
ARM_PATCH_PHYS_VIRT;Patch phys-to-virt and virt-to-phys translation functions at boot and module load time according to the position of the kernel in system memory.  This can only be used with non-XIP MMU kernels where the base of physical memory is at a 16MB boundary.  Only disable this option if you know that you do not require this feature (eg, building a kernel for a single machine) and you need to shrink the kernel to the minimal size.
ARCH_CATS;Say Y here if you intend to run this kernel on the CATS.  Saying N will reduce the size of the Footbridge kernel.
ARCH_PERSONAL_SERVER;Say Y here if you intend to run this kernel on the Compaq Personal Server.  Saying N will reduce the size of the Footbridge kernel.  The Compaq Personal Server is not available for purchase. There are no product plans beyond the current research prototypes at this time.  Information is available at:  <http://www.crl.hpl.hp.com/projects/personalserver/>  If you have any questions or comments about the  Compaq Personal Server, send e-mail to <skiff@crl.dec.com>.
ARCH_EBSA285_ADDIN;Say Y here if you intend to run this kernel on the EBSA285 card in addin mode.  Saying N will reduce the size of the Footbridge kernel.
ARCH_EBSA285_HOST;Say Y here if you intend to run this kernel on the EBSA285 card in host (central function) mode.  Saying N will reduce the size of the Footbridge kernel.
ARCH_NETWINDER;Say Y here if you intend to run this kernel on the Rebel.COM NetWinder.  Information about this machine can be found at:  <http://www.netwinder.org/>  Saying N will reduce the size of the Footbridge kernel.
S3C24XX_PLL;Compile in support for changing the PLL frequency from the S3C24XX series CPUfreq driver. The PLL takes time to settle after a frequency change, so by default it is not enabled.  This also means that the PLL tables for the selected CPU(s) will be built which may increase the size of the kernel image.
SAMSUNG_PM_CHECK;Enable the PM code's memory area checksum over sleep. This option will generate CRCs of all blocks of memory, and store them before going to sleep. The blocks are then checked on resume for any errors.  Note, this can take several seconds depending on memory size and CPU speed.  See <file:Documentation/arm/Samsung-S3C24XX/Suspend.txt>
SAMSUNG_PM_CHECK_CHUNKSIZE;Set the chunksize in Kilobytes of the CRC for checking memory corruption over suspend and resume. A smaller value will mean that the CRC data block will take more memory, but wil identify any faults with better precision.  See <file:Documentation/arm/Samsung-S3C24XX/Suspend.txt>
CPU_FA526;The FA526 is a version of the ARMv4 compatible processor with Branch Target Buffer, Unified TLB and cache line size 16.  Say Y if you want support for the FA526 processor. Otherwise, say N.
CPU_DCACHE_SIZE;Some cores are synthesizable to have various sized cache. For ARM946E-S case, it can vary from 0KB to 1MB. To support such cache operations, it is efficient to know the size before compile time. If your SoC is configured to have a different size, define the value here with proper conditions.
ARM_L1_CACHE_SHIFT_6;Setting ARM L1 cache line size to 64 Bytes.
ARM_L1_CACHE_SHIFT_7;Setting ARM L1 cache line size to 128 Bytes.
DEBUG_ALIGN_RODATA;If this option is enabled, sections that may potentially be marked as read only or non-executable will be aligned up to the section size of the kernel. This prevents sections from being split into pages and avoids a potential TLB penalty. The downside is an increase in alignment and potentially wasted space. Turn on this option if performance is more important than memory pressure.  If in doubt, say N.
SET_MEM_PARAM;Say Y to manually set the base addresses and sizes. otherwise, the default values are assigned.
ARM_MODULE_PLTS;Allocate PLTs when loading modules so that jumps and calls whose targets are too far away for their relative offsets to be encoded in the instructions themselves can be bounced via veneers in the module's PLT. This allows modules to be allocated in the generic vmalloc area after the dedicated module memory area has been exhausted. The modules will use slightly more memory, but after rounding up to page size, the actual memory footprint is usually the same.  Say y if you are getting out of memory errors while loading modules
FPE_NWFPE_XP;Say Y to include 80-bit support in the kernel floating-point emulator.  Otherwise, only 32 and 64-bit support is compiled in. Note that gcc does not generate 80-bit operations by default, so in most cases this option only enlarges the size of the floating point emulator without any good reason.  You almost surely want to say N here.
SINGLE_MEMORY_CHUNK;Ignore all but the first contiguous chunk of physical memory for VM purposes.  This will save a few bytes kernel size and may speed up some operations.  Say N if not sure.
RAMSIZE;Define the size of the system RAM. If you select 0 then the kernel will try to probe the RAM size at runtime. This is not supported on all CPU types.
ROMSIZE;Size of the ROM device. On some platforms this is used to setup the chip select that controls the boot ROM device.
PROC_HARDWARE;Say Y here to support the /proc/hardware file, which gives you access to information about the machine you're running on, including the model, CPU, MMU, clock speed, BogoMIPS rating, and memory size.
PARISC_PAGE_SIZE_4KB;This lets you select the page size of the kernel.  For best performance, a page size of 16KB is recommended.  For best compatibility with 32bit applications, a page size of 4KB should be selected (the vast majority of 32bit binaries work perfectly fine with a larger page size).  4KB                For best 32bit compatibility 16KB               For best performance 64KB               For best performance, might give more overhead.  If you don't know what to do, choose 4KB.
ALPHA_EB164;EB164 21164 evaluation board from DEC.  Uses 21164 and ALCOR.  Has ISA and PCI expansion (3 ISA slots, 2 64-bit PCI slots (one is shared with an ISA slot) and 2 32-bit PCI slots.  Uses plus-in Bcache SIMMs. I/O sub-system provides SuperI/O (2S, 1P, FD), KBD, MOUSE (PS2 style), RTC/NVRAM.  Boot ROM is Flash.  PC-AT-sized motherboard.  Requires power supply with 3.3V output.
ALPHA_EB66;A Digital DS group board.  Uses 21066 or 21066A.  I/O sub-system is identical to EB64+.  Baby PC-AT size.  Runs from standard PC power supply.  The EB66 schematic was published as a marketing poster advertising the 21066 as the first microprocessor in the world with embedded PCI.
ALPHA_NONAME;The AXPpci33 (aka NoName), is based on the EB66 (includes the Multia UDB).  This design was produced by Digital's Technical OEM (TOEM) group. It uses the 21066 processor running at 166MHz or 233MHz. It is a baby-AT size, and runs from a standard PC power supply. It has 5 ISA slots and 3 PCI slots (one pair are a shared slot). There are 2 versions, with either PS/2 or large DIN connectors for the keyboard.
ALPHA_EB64P;Uses 21064 or 21064A and APECs.  Has ISA and PCI expansion (3 ISA, 2 PCI, one pair are on a shared slot). Supports 36-bit DRAM SIMs. ISA bus generated by Intel SaturnI/O PCI-ISA bridge. On-board SCSI (NCR 810 on PCI) Ethernet (Digital 21040), KBD, MOUSE (PS2 style), SuperI/O (2S, 1P, FD), RTC/NVRAM. Boot ROM is EPROM.  PC-AT size. Runs from standard PC power supply.
ETRAX_DRAM_SIZE;Size of DRAM (decimal in MB) typically 2, 8 or 16.
ETRAX_VMEM_SIZE;Size of Video accessible memory (decimal, in MB).
ETRAX_PTABLE_SECTOR;Byte-offset of the partition table in the first flash chip. The default value is 64kB and should not be changed unless you know exactly what you are doing. The only valid reason for changing this is when the flash block size is bigger than 64kB (e.g. when using two parallel 16 bit flashes).
ETRAX_I2C_EEPROM;Enables I2C EEPROM (non-volatile RAM) on PB0 and PB1 using the I2C driver.  Select size option: Probed, 2k, 8k, 16k. (Probing works for 2k and 8k but not that well for 16k)
ETRAX_I2C_EEPROM_PROBE;Specifies size or auto probe of the EEPROM size. Options: Probed, 2k, 8k, 16k. (Probing works for 2k and 8k but not that well for 16k)
CAVIUM_ERRATUM_22375;Enable workaround for erratum 22375, 24313.  This implements two gicv3-its errata workarounds for ThunderX. Both with small impact affecting only ITS table allocation.    erratum 22375: only alloc 8MB table size   erratum 24313: ignore memory access type  The fixes are in ITS initialization and basically ignore memory access type and table size provided by the TYPER and BASER registers.  If unsure, say Y.
QCOM_QDF2400_ERRATUM_0065;On Qualcomm Datacenter Technologies QDF2400 SoC, ITS hardware reports ITE size incorrectly. The GITS_TYPER.ITT_Entry_size field should have been indicated as 16Bytes (0xf), not 8Bytes (0x7).  If unsure, say Y.
DEBUG_HWERR;When enabled, the hardware error interrupt is never disabled, and will happen immediately when an error condition occurs.  This comes at a slight cost in code size, but is necessary if you are getting hardware error interrupts and need to know where they are coming from.
DEBUG_BFIN_HWTRACE_EXPAND_LEN;This sets the size of the software buffer that the trace information is kept in. 0 for (2^0)  1k, or 256 entries, 1 for (2^1)  2k, or 512 entries, 2 for (2^2)  4k, or 1024 entries, 3 for (2^3)  8k, or 2048 entries, 4 for (2^4) 16k, or 4096 entries
