CGROUP_HUGETLB;Provides a cgroup controller for HugeTLB pages. When you enable this, you can put a per cgroup limit on HugeTLB usage. The limit is enforced during page fault. Since HugeTLB doesn't support page reclaim, enforcing the limit at page fault time implies that, the application will get SIGBUS signal if it tries to access HugeTLB pages beyond its limit. This requires the application to know beforehand how much HugeTLB pages it would require for its use. The control group is tracked in the third page lru pointer. This means that we cannot use the controller with huge page less than 3 pages.
MMAP_ALLOW_UNINITIALIZED;Normally, and according to the Linux spec, anonymous memory obtained from mmap() has it's contents cleared before it is passed to userspace.  Enabling this config option allows you to request that mmap() skip that if it is given an MAP_UNINITIALIZED flag, thus providing a huge performance boost.  If this option is not enabled, then the flag will be ignored.  This is taken advantage of by uClibc's malloc(), and also by ELF-FDPIC binfmt's brk and stack allocator.  Because of the obvious security issues, this option should only be enabled on embedded devices where you control what is run in userspace.  Since that isn't generally a problem on no-MMU systems, it is normally safe to say Y here.  See Documentation/nommu-mmap.txt for more information.
LBDAF;Enable block devices or files of size 2TB and larger.  This option is required to support the full capacity of large (2TB+) block devices, including RAID, disk, Network Block Device, Logical Volume Manager (LVM) and loopback.  This option also enables support for single files larger than 2TB.  The ext4 filesystem requires that this feature be enabled in order to support filesystems that have the huge_file feature enabled.  Otherwise, it will refuse to mount in the read-write mode any filesystems that use the huge_file feature, which is enabled by default by mke2fs.ext4.  The GFS2 filesystem also requires this feature.  If unsure, say Y.
BALLOON_COMPACTION;Memory fragmentation introduced by ballooning might reduce significantly the number of 2MB contiguous memory blocks that can be used within a guest, thus imposing performance penalties associated with the reduced number of transparent huge pages that could be used by the guest workload. Allowing the compaction & migration for memory pages enlisted as being part of memory balloon devices avoids the scenario aforementioned and helps improving memory defragmentation.
MIGRATION;Allows the migration of the physical location of pages of processes while the virtual addresses are not changed. This is useful in two situations. The first is on NUMA systems to put pages nearer to the processors accessing. The second is when allocating huge pages as migration can relocate pages to satisfy a huge page allocation instead of reclaiming.
TRANSPARENT_HUGEPAGE;Transparent Hugepages allows the kernel to use huge pages and huge tlb transparently to the applications whenever possible. This feature can improve computing performance to certain applications by speeding up page faults during memory allocation, by reducing the number of tlb misses and by speeding up the pagetable walking.  If memory constrained on embedded, you may want to say N.
TRANSPARENT_HUGEPAGE_ALWAYS;Enabling Transparent Hugepage always, can increase the memory footprint of applications without a guaranteed benefit but it will work automatically for all applications.
TRANSPARENT_HUGEPAGE_MADVISE;Enabling Transparent Hugepage madvise, will only provide a performance improvement benefit to the applications using madvise(MADV_HUGEPAGE) but it won't risk to increase the memory footprint of applications without a guaranteed benefit.
THP_SWAP;Swap transparent huge pages in one piece, without splitting. XXX: For now this only does clustered swap space allocation.  For selection by architectures with reasonable THP sizes.
XFS_DEBUG;Say Y here to get an XFS build with many debugging features, including ASSERT checks, function wrappers around macros, and extra sanity-checking functions in various code paths.  Note that the resulting code will be HUGE and SLOW, and probably not useful unless you are debugging a particular problem.  Say N unless you are an XFS developer, or you play one on TV.
HUGETLBFS;hugetlbfs is a filesystem backing for HugeTLB pages, based on ramfs. For architectures that support it, say Y here and read <file:Documentation/vm/hugetlbpage.txt> for details.  If unsure, say N.
FORCE_MAX_ZONEORDER;The kernel memory allocator divides physically contiguous memory blocks into zones, where each zone is a power of two number of pages.  This option selects the largest power of two that the kernel keeps in the memory allocator.  If you need to allocate very large blocks of physically contiguous memory, then you may need to increase this value.  This config option is actually maximum order plus one. For example, a value of 11 means that the largest free memory block is 2^10 pages.  We make sure that we can allocate upto a HugePage size for each configuration. Hence we have :       MAX_ORDER = (PMD_SHIFT - PAGE_SHIFT) + 1 => PAGE_SHIFT - 2  However for 4K, we choose a higher default value, 11 as opposed to 10, giving us 4M allocations matching the default size used by generic code.
ARC_CPU_HS;Support for ARC HS38x Cores based on ARCv2 ISA The notable features are:   - SMP configurations of upto 4 core with coherency   - Optional L2 Cache and IO-Coherency   - Revised Interrupt Architecture (multiple priorites, reg banks,       auto stack switch, auto regfile save/restore)   - MMUv4 (PIPT dcache, Huge Pages)   - Instructions for       * 64bit load/store: LDD, STD       * Hardware assisted divide/remainder: DIV, REM       * Function prologue/epilogue: ENTER_S, LEAVE_S       * IRQ enable/disable: CLRI, SETI       * pop count: FFS, FLS       * SETcc, BMSKN, XBFU...
ARCH_DISCONTIGMEM_ENABLE;Say Y to support efficient handling of discontiguous physical memory, for architectures which are either NUMA (Non-Uniform Memory Access) or have huge holes in the physical address space for other reasons. See <file:Documentation/vm/numa> for more.
